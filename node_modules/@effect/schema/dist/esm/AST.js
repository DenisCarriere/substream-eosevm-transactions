/**
 * @since 1.0.0
 */
import { dual, identity, pipe } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Hash from "effect/Hash";
import * as Number from "effect/Number";
import * as Option from "effect/Option";
import * as Order from "effect/Order";
import * as Predicate from "effect/Predicate";
import * as ReadonlyArray from "effect/ReadonlyArray";
import * as Internal from "./internal/ast.js";
/**
 * @category annotations
 * @since 1.0.0
 */
export const BrandAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Brand");
/**
 * @category annotations
 * @since 1.0.0
 */
export const TypeAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Type");
/**
 * @category annotations
 * @since 1.0.0
 */
export const MessageAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Message");
/**
 * @category annotations
 * @since 1.0.0
 */
export const IdentifierAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Identifier");
/**
 * @category annotations
 * @since 1.0.0
 */
export const TitleAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Title");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DescriptionAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Description");
/**
 * @category annotations
 * @since 1.0.0
 */
export const ExamplesAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Examples");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DefaultAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Default");
/**
 * @category annotations
 * @since 1.0.0
 */
export const JSONSchemaAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/JSONSchema");
/**
 * @category annotations
 * @since 1.0.0
 */
export const DocumentationAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Documentation");
/**
 * @category annotations
 * @since 1.0.0
 */
export const getAnnotation = /*#__PURE__*/dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? Option.some(annotated.annotations[key]) : Option.none());
/**
 * @category annotations
 * @since 1.0.0
 */
export const getMessageAnnotation = /*#__PURE__*/getAnnotation(MessageAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getTitleAnnotation = /*#__PURE__*/getAnnotation(TitleAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getIdentifierAnnotation = /*#__PURE__*/getAnnotation(IdentifierAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getDescriptionAnnotation = /*#__PURE__*/getAnnotation(DescriptionAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getExamplesAnnotation = /*#__PURE__*/getAnnotation(ExamplesAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getDefaultAnnotation = /*#__PURE__*/getAnnotation(DefaultAnnotationId);
/**
 * @category annotations
 * @since 1.0.0
 */
export const getJSONSchemaAnnotation = /*#__PURE__*/getAnnotation(JSONSchemaAnnotationId);
/**
 * @category constructors
 * @since 1.0.0
 */
export const createDeclaration = (typeParameters, decodeUnknown, encodeUnknown, annotations = {}) => ({
  _tag: "Declaration",
  typeParameters,
  decodeUnknown,
  encodeUnknown,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isDeclaration = ast => ast._tag === "Declaration";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createLiteral = (literal, annotations = {}) => ({
  _tag: "Literal",
  literal,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isLiteral = ast => ast._tag === "Literal";
/** @internal */
export const _null = /*#__PURE__*/createLiteral(null, {
  [IdentifierAnnotationId]: "null"
});
/**
 * @category constructors
 * @since 1.0.0
 */
export const createUniqueSymbol = (symbol, annotations = {}) => ({
  _tag: "UniqueSymbol",
  symbol,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isUniqueSymbol = ast => ast._tag === "UniqueSymbol";
/**
 * @category constructors
 * @since 1.0.0
 */
export const undefinedKeyword = {
  _tag: "UndefinedKeyword",
  annotations: {
    [TitleAnnotationId]: "undefined"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isUndefinedKeyword = ast => ast._tag === "UndefinedKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const voidKeyword = {
  _tag: "VoidKeyword",
  annotations: {
    [TitleAnnotationId]: "void"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isVoidKeyword = ast => ast._tag === "VoidKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const neverKeyword = {
  _tag: "NeverKeyword",
  annotations: {
    [TitleAnnotationId]: "never"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isNeverKeyword = ast => ast._tag === "NeverKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const unknownKeyword = {
  _tag: "UnknownKeyword",
  annotations: {
    [TitleAnnotationId]: "unknown"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isUnknownKeyword = ast => ast._tag === "UnknownKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const anyKeyword = {
  _tag: "AnyKeyword",
  annotations: {
    [TitleAnnotationId]: "any"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isAnyKeyword = ast => ast._tag === "AnyKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const stringKeyword = {
  _tag: "StringKeyword",
  annotations: {
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isStringKeyword = ast => ast._tag === "StringKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const numberKeyword = {
  _tag: "NumberKeyword",
  annotations: {
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isNumberKeyword = ast => ast._tag === "NumberKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const booleanKeyword = {
  _tag: "BooleanKeyword",
  annotations: {
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isBooleanKeyword = ast => ast._tag === "BooleanKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const bigIntKeyword = {
  _tag: "BigIntKeyword",
  annotations: {
    [TitleAnnotationId]: "bigint",
    [DescriptionAnnotationId]: "a bigint"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isBigIntKeyword = ast => ast._tag === "BigIntKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const symbolKeyword = {
  _tag: "SymbolKeyword",
  annotations: {
    [TitleAnnotationId]: "symbol",
    [DescriptionAnnotationId]: "a symbol"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isSymbolKeyword = ast => ast._tag === "SymbolKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const objectKeyword = {
  _tag: "ObjectKeyword",
  annotations: {
    [IdentifierAnnotationId]: "object",
    [TitleAnnotationId]: "object",
    [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isObjectKeyword = ast => ast._tag === "ObjectKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createEnums = (enums, annotations = {}) => ({
  _tag: "Enums",
  enums,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isEnums = ast => ast._tag === "Enums";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createTemplateLiteral = (head, spans, annotations = {}) => ReadonlyArray.isNonEmptyReadonlyArray(spans) ? {
  _tag: "TemplateLiteral",
  head,
  spans,
  annotations
} : createLiteral(head);
/**
 * @category guards
 * @since 1.0.0
 */
export const isTemplateLiteral = ast => ast._tag === "TemplateLiteral";
/**
 * @since 1.0.0
 */
export const createElement = (type, isOptional) => ({
  type,
  isOptional
});
/**
 * @category constructors
 * @since 1.0.0
 */
export const createTuple = (elements, rest, isReadonly, annotations = {}) => ({
  _tag: "Tuple",
  elements,
  rest,
  isReadonly,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isTuple = ast => ast._tag === "Tuple";
/**
 * @since 1.0.0
 */
export const createPropertySignature = (name, type, isOptional, isReadonly, annotations = {}) => ({
  name,
  type,
  isOptional,
  isReadonly,
  annotations
});
/**
 * @since 1.0.0
 */
export const isParameter = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
    default:
      return false;
  }
};
/**
 * @since 1.0.0
 */
export const createIndexSignature = (parameter, type, isReadonly) => {
  if (isParameter(parameter)) {
    return {
      parameter,
      type,
      isReadonly
    };
  }
  throw new Error("An index signature parameter type must be 'string', 'symbol', a template literal type or a refinement of the previous types");
};
/**
 * @category constructors
 * @since 1.0.0
 */
export const createTypeLiteral = (propertySignatures, indexSignatures, annotations = {}) => {
  // check for duplicate property signatures
  const keys = {};
  for (let i = 0; i < propertySignatures.length; i++) {
    const name = propertySignatures[i].name;
    if (Object.prototype.hasOwnProperty.call(keys, name)) {
      throw new Error(`Duplicate property signature ${String(name)}`);
    }
    keys[name] = null;
  }
  // check for duplicate index signatures
  const parameters = {
    string: false,
    symbol: false
  };
  for (let i = 0; i < indexSignatures.length; i++) {
    const parameter = getParameterBase(indexSignatures[i].parameter);
    if (isStringKeyword(parameter)) {
      if (parameters.string) {
        throw new Error("Duplicate index signature for type `string`");
      }
      parameters.string = true;
    } else if (isSymbolKeyword(parameter)) {
      if (parameters.symbol) {
        throw new Error("Duplicate index signature for type `symbol`");
      }
      parameters.symbol = true;
    }
  }
  return {
    _tag: "TypeLiteral",
    propertySignatures: sortPropertySignatures(propertySignatures),
    indexSignatures: sortIndexSignatures(indexSignatures),
    annotations
  };
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isTypeLiteral = ast => ast._tag === "TypeLiteral";
const isMembers = as => as.length > 1;
/**
 * @category constructors
 * @since 1.0.0
 */
export const createUnion = (candidates, annotations = {}) => {
  const types = unify(candidates);
  if (isMembers(types)) {
    return {
      _tag: "Union",
      types: sortUnionMembers(types),
      annotations
    };
  }
  if (ReadonlyArray.isNonEmptyReadonlyArray(types)) {
    return types[0];
  }
  return neverKeyword;
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isUnion = ast => ast._tag === "Union";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createSuspend = (f, annotations = {}) => ({
  _tag: "Suspend",
  f: Internal.memoizeThunk(f),
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isSuspend = ast => ast._tag === "Suspend";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createRefinement = (from, filter, annotations = {}) => {
  return {
    _tag: "Refinement",
    from,
    filter,
    annotations
  };
};
/**
 * @category guards
 * @since 1.0.0
 */
export const isRefinement = ast => ast._tag === "Refinement";
/**
 * @category model
 * @since 1.0.0
 */
export const createTransform = (from, to, transformation, annotations = {}) => ({
  _tag: "Transform",
  from,
  to,
  transformation,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
export const isTransform = ast => ast._tag === "Transform";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createFinalTransformation = (decode, encode) => ({
  _tag: "FinalTransformation",
  decode,
  encode
});
/**
 * @category guard
 * @since 1.0.0
 */
export const isFinalTransformation = ast => ast._tag === "FinalTransformation";
/**
 * @category constructors
 * @since 1.0.0
 */
export const composeTransformation = {
  _tag: "ComposeTransformation"
};
/**
 * @category guard
 * @since 1.0.0
 */
export const isComposeTransformation = ast => ast._tag === "ComposeTransformation";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createFinalPropertySignatureTransformation = (decode, encode) => ({
  _tag: "FinalPropertySignatureTransformation",
  decode,
  encode
});
/**
 * @category guard
 * @since 1.0.0
 */
export const isFinalPropertySignatureTransformation = ast => ast._tag === "FinalPropertySignatureTransformation";
/**
 * @category constructors
 * @since 1.0.0
 */
export const createPropertySignatureTransform = (from, to, propertySignatureTransformation) => ({
  from,
  to,
  propertySignatureTransformation
});
/**
 * @category constructors
 * @since 1.0.0
 */
export const createTypeLiteralTransformation = propertySignatureTransformations => {
  // check for duplicate property signature transformations
  const keys = {};
  for (const pst of propertySignatureTransformations) {
    const key = pst.from;
    if (keys[key]) {
      throw new Error(`Duplicate property signature transformation ${String(key)}`);
    }
    keys[key] = true;
  }
  return {
    _tag: "TypeLiteralTransformation",
    propertySignatureTransformations
  };
};
/**
 * @category guard
 * @since 1.0.0
 */
export const isTypeLiteralTransformation = ast => ast._tag === "TypeLiteralTransformation";
// -------------------------------------------------------------------------------------
// API
// -------------------------------------------------------------------------------------
/**
 * Adds a group of annotations, potentially overwriting existing annotations.
 *
 * @since 1.0.0
 */
export const mergeAnnotations = (ast, annotations) => {
  return {
    ...ast,
    annotations: {
      ...ast.annotations,
      ...annotations
    }
  };
};
/**
 * Adds an annotation, potentially overwriting the existing annotation with the specified id.
 *
 * @since 1.0.0
 */
export const setAnnotation = (ast, sym, value) => {
  return {
    ...ast,
    annotations: {
      ...ast.annotations,
      [sym]: value
    }
  };
};
/**
 * Adds a rest element to the end of a tuple, or throws an exception if the rest element is already present.
 *
 * @since 1.0.0
 */
export const appendRestElement = (ast, restElement) => {
  if (Option.isSome(ast.rest)) {
    // example: `type A = [...string[], ...number[]]` is illegal
    throw new Error("A rest element cannot follow another rest element. ts(1265)");
  }
  return createTuple(ast.elements, Option.some([restElement]), ast.isReadonly);
};
/**
 * Appends an element to a tuple or throws an exception in the following cases:
 * - A required element cannot follow an optional element. ts(1257)
 * - An optional element cannot follow a rest element. ts(1266)
 *
 * @since 1.0.0
 */
export const appendElement = (ast, newElement) => {
  if (ast.elements.some(e => e.isOptional) && !newElement.isOptional) {
    throw new Error("A required element cannot follow an optional element. ts(1257)");
  }
  return pipe(ast.rest, Option.match({
    onNone: () => createTuple([...ast.elements, newElement], Option.none(), ast.isReadonly),
    onSome: rest => {
      if (newElement.isOptional) {
        throw new Error("An optional element cannot follow a rest element. ts(1266)");
      }
      return createTuple(ast.elements, Option.some([...rest, newElement.type]), ast.isReadonly);
    }
  }));
};
/**
 * Equivalent at runtime to the TypeScript type-level `keyof` operator.
 *
 * @since 1.0.0
 */
export const keyof = ast => createUnion(_keyof(ast));
/** @internal */
export const getTemplateLiteralRegex = ast => {
  let pattern = `^${ast.head}`;
  for (const span of ast.spans) {
    if (isStringKeyword(span.type)) {
      pattern += ".*";
    } else if (isNumberKeyword(span.type)) {
      pattern += "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
    }
    pattern += span.literal;
  }
  pattern += "$";
  return new RegExp(pattern);
};
/**
 * @since 1.0.0
 */
export const getPropertySignatures = ast => {
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
  }
  return getPropertyKeys(ast).map(name => getPropertyKeyIndexedAccess(ast, name));
};
/** @internal */
export const getNumberIndexedAccess = ast => {
  switch (ast._tag) {
    case "Tuple":
      {
        let hasOptional = false;
        const out = [];
        for (const e of ast.elements) {
          if (e.isOptional) {
            hasOptional = true;
          }
          out.push(e.type);
        }
        if (hasOptional) {
          out.push(undefinedKeyword);
        }
        if (Option.isSome(ast.rest)) {
          for (const e of ast.rest.value) {
            out.push(e);
          }
        }
        return createUnion(out);
      }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return createUnion(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(`getNumberIndexedAccess: unsupported schema (${format(ast)})`);
};
/** @internal */
export const getPropertyKeyIndexedAccess = (ast, name) => {
  switch (ast._tag) {
    case "TypeLiteral":
      {
        const ops = ReadonlyArray.findFirst(ast.propertySignatures, ps => ps.name === name);
        if (Option.isSome(ops)) {
          return ops.value;
        } else {
          if (Predicate.isString(name)) {
            for (const is of ast.indexSignatures) {
              const parameterBase = getParameterBase(is.parameter);
              switch (parameterBase._tag) {
                case "TemplateLiteral":
                  {
                    const regex = getTemplateLiteralRegex(parameterBase);
                    if (regex.test(name)) {
                      return createPropertySignature(name, is.type, false, false);
                    }
                    break;
                  }
                case "StringKeyword":
                  return createPropertySignature(name, is.type, false, false);
              }
            }
          } else if (Predicate.isSymbol(name)) {
            for (const is of ast.indexSignatures) {
              const parameterBase = getParameterBase(is.parameter);
              if (isSymbolKeyword(parameterBase)) {
                return createPropertySignature(name, is.type, false, false);
              }
            }
          }
        }
        break;
      }
    case "Union":
      return createPropertySignature(name, createUnion(ast.types.map(ast => getPropertyKeyIndexedAccess(ast, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
  }
  return createPropertySignature(name, neverKeyword, false, true);
};
const getPropertyKeys = ast => {
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map(ps => ps.name);
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast) => ReadonlyArray.intersection(out, getPropertyKeys(ast)), getPropertyKeys(ast.types[0]));
  }
  return [];
};
/**
 * Create a record with the specified key type and value type.
 *
 * @since 1.0.0
 */
export const createRecord = (key, value, isReadonly) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = key => {
    switch (key._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(createIndexSignature(key, value, isReadonly));
        break;
      case "Literal":
        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {
          propertySignatures.push(createPropertySignature(key.literal, value, false, isReadonly));
        } else {
          throw new Error(`createRecord: unsupported literal (${formatUnknown(key.literal)})`);
        }
        break;
      case "UniqueSymbol":
        propertySignatures.push(createPropertySignature(key.symbol, value, false, isReadonly));
        break;
      case "Union":
        key.types.forEach(go);
        break;
      default:
        throw new Error(`createRecord: unsupported key schema (${format(key)})`);
    }
  };
  go(key);
  return createTypeLiteral(propertySignatures, indexSignatures);
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Pick`.
 *
 * @since 1.0.0
 */
export const pick = (ast, keys) => createTypeLiteral(keys.map(key => getPropertyKeyIndexedAccess(ast, key)), []);
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Omit`.
 *
 * @since 1.0.0
 */
export const omit = (ast, keys) => pick(ast, getPropertyKeys(ast).filter(name => !keys.includes(name)));
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Partial`.
 *
 * @since 1.0.0
 */
export const partial = ast => {
  switch (ast._tag) {
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(e.type, true)), pipe(ast.rest, Option.map(rest => [createUnion([...rest, undefinedKeyword])])), ast.isReadonly);
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, true, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return createUnion(ast.types.map(member => partial(member)));
    case "Suspend":
      return createSuspend(() => partial(ast.f()));
    case "Declaration":
      throw new Error("`partial` cannot handle declarations");
    case "Refinement":
      throw new Error("`partial` cannot handle refinements");
    case "Transform":
      throw new Error("`partial` cannot handle transformations");
    default:
      return ast;
  }
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Required`.
 *
 * @since 1.0.0
 */
export const required = ast => {
  switch (ast._tag) {
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(e.type, false)), pipe(ast.rest, Option.map(rest => {
        const u = createUnion([...rest]);
        return ReadonlyArray.map(rest, () => u);
      })), ast.isReadonly);
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return createUnion(ast.types.map(member => required(member)));
    case "Suspend":
      return createSuspend(() => required(ast.f()));
    case "Declaration":
      throw new Error("`required` cannot handle declarations");
    case "Refinement":
      throw new Error("`required` cannot handle refinements");
    case "Transform":
      throw new Error("`required` cannot handle transformations");
    default:
      return ast;
  }
};
/**
 * Creates a new AST with shallow mutability applied to its properties.
 *
 * @param ast - The original AST to make properties mutable (shallowly).
 *
 * @since 1.0.0
 */
export const mutable = ast => {
  switch (ast._tag) {
    case "Tuple":
      return createTuple(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(ps => createPropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations)), ast.indexSignatures.map(is => createIndexSignature(is.parameter, is.type, false)), ast.annotations);
    case "Union":
      return createUnion(ast.types.map(mutable), ast.annotations);
    case "Suspend":
      return createSuspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement":
      return createRefinement(mutable(ast.from), ast.filter, ast.annotations);
    case "Transform":
      return createTransform(mutable(ast.from), mutable(ast.to), ast.transformation, ast.annotations);
  }
  return ast;
};
/**
 * @since 1.0.0
 */
export const getCompiler = match => {
  const compile = ast => match[ast._tag](ast, compile);
  return compile;
};
/** @internal */
export const getToPropertySignatures = ps => ps.map(p => createPropertySignature(p.name, to(p.type), p.isOptional, p.isReadonly, p.annotations));
/** @internal */
export const getToIndexSignatures = ps => ps.map(is => createIndexSignature(is.parameter, to(is.type), is.isReadonly));
/**
 * @since 1.0.0
 */
export const to = ast => {
  switch (ast._tag) {
    case "Declaration":
      return createDeclaration(ast.typeParameters.map(to), ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(to(e.type), e.isOptional)), Option.map(ast.rest, ReadonlyArray.map(to)), ast.isReadonly, ast.annotations);
    case "TypeLiteral":
      return createTypeLiteral(getToPropertySignatures(ast.propertySignatures), getToIndexSignatures(ast.indexSignatures), ast.annotations);
    case "Union":
      return createUnion(ast.types.map(to), ast.annotations);
    case "Suspend":
      return createSuspend(() => to(ast.f()), ast.annotations);
    case "Refinement":
      return createRefinement(to(ast.from), ast.filter, ast.annotations);
    case "Transform":
      return to(ast.to);
  }
  return ast;
};
const preserveIdentifierAnnotation = annotated => {
  return Option.match(getIdentifierAnnotation(annotated), {
    onNone: () => undefined,
    onSome: identifier => ({
      [IdentifierAnnotationId]: identifier
    })
  });
};
/**
 * @since 1.0.0
 */
export const from = ast => {
  switch (ast._tag) {
    case "Declaration":
      return createDeclaration(ast.typeParameters.map(from), ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(from(e.type), e.isOptional)), Option.map(ast.rest, ReadonlyArray.map(from)), ast.isReadonly, preserveIdentifierAnnotation(ast));
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(p => createPropertySignature(p.name, from(p.type), p.isOptional, p.isReadonly)), ast.indexSignatures.map(is => createIndexSignature(is.parameter, from(is.type), is.isReadonly)), preserveIdentifierAnnotation(ast));
    case "Union":
      return createUnion(ast.types.map(from), preserveIdentifierAnnotation(ast));
    case "Suspend":
      return createSuspend(() => from(ast.f()), preserveIdentifierAnnotation(ast));
    case "Refinement":
    case "Transform":
      return from(ast.from);
  }
  return ast;
};
const toStringMemoSet = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("@effect/schema/AST/toStringMemoSet"), () => new WeakSet());
const containerASTTags = {
  Declaration: true,
  Refinement: true,
  Tuple: true,
  TypeLiteral: true,
  Union: true,
  Suspend: true,
  Transform: true
};
const isContainerAST = ast => "_tag" in ast && Predicate.isString(ast["_tag"]) && ast["_tag"] in containerASTTags;
/** @internal */
export const toString = ast => JSON.stringify(ast, (key, value) => {
  if (Predicate.isSymbol(value)) {
    return String(value);
  }
  if (typeof value === "object" && value !== null) {
    if (isContainerAST(value)) {
      if (toStringMemoSet.has(value)) {
        return "<suspended schema>";
      }
      toStringMemoSet.add(value);
      if (isSuspend(value)) {
        const out = value.f();
        if (toStringMemoSet.has(out)) {
          return "<suspended schema>";
        }
        toStringMemoSet.add(out);
        return out;
      }
    } else if (key === "annotations") {
      const out = {};
      for (const k of Internal.ownKeys(value)) {
        out[String(k)] = value[k];
      }
      return out;
    }
  }
  return value;
}, 2);
/**
 * @since 1.0.0
 */
export const hash = ast => Hash.string(toString(ast));
/** @internal */
export const getCardinality = ast => {
  switch (ast._tag) {
    case "NeverKeyword":
      return 0;
    case "Literal":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "UniqueSymbol":
      return 1;
    case "BooleanKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
    case "ObjectKeyword":
      return 5;
    case "UnknownKeyword":
    case "AnyKeyword":
      return 6;
    default:
      return 4;
  }
};
const sortPropertySignatures = /*#__PURE__*/ReadonlyArray.sort( /*#__PURE__*/pipe(Number.Order, /*#__PURE__*/Order.mapInput(ps => getCardinality(ps.type))));
const sortIndexSignatures = /*#__PURE__*/ReadonlyArray.sort( /*#__PURE__*/pipe(Number.Order, /*#__PURE__*/Order.mapInput(is => {
  switch (getParameterBase(is.parameter)._tag) {
    case "StringKeyword":
      return 2;
    case "SymbolKeyword":
      return 3;
    case "TemplateLiteral":
      return 1;
  }
})));
const WeightOrder = /*#__PURE__*/Order.tuple(Number.Order, Number.Order, Number.Order);
const maxWeight = /*#__PURE__*/Order.max(WeightOrder);
const emptyWeight = [0, 0, 0];
const maxWeightAll = weights => weights.reduce(maxWeight, emptyWeight);
/** @internal */
export const getWeight = ast => {
  switch (ast._tag) {
    case "Tuple":
      {
        const y = ast.elements.length;
        const z = Option.isSome(ast.rest) ? ast.rest.value.length : 0;
        return [2, y, z];
      }
    case "TypeLiteral":
      {
        const y = ast.propertySignatures.length;
        const z = ast.indexSignatures.length;
        return y + z === 0 ? [-4, 0, 0] : [4, y, z];
      }
    case "Declaration":
      {
        return [6, 0, 0];
      }
    case "Suspend":
      return [8, 0, 0];
    case "Union":
      return maxWeightAll(ast.types.map(getWeight));
    case "Refinement":
      {
        const [x, y, z] = getWeight(ast.from);
        return [x + 1, y, z];
      }
    case "Transform":
      return getWeight(ast.from);
    case "ObjectKeyword":
      return [-2, 0, 0];
    case "UnknownKeyword":
    case "AnyKeyword":
      return [-4, 0, 0];
    default:
      return emptyWeight;
  }
};
const sortUnionMembers = /*#__PURE__*/ReadonlyArray.sort( /*#__PURE__*/Order.reverse( /*#__PURE__*/Order.mapInput(WeightOrder, getWeight)));
const unify = candidates => {
  let out = pipe(candidates, ReadonlyArray.flatMap(ast => {
    switch (ast._tag) {
      case "NeverKeyword":
        return [];
      case "Union":
        return ast.types;
      default:
        return [ast];
    }
  }));
  if (out.some(isAnyKeyword)) {
    return [anyKeyword];
  }
  if (out.some(isUnknownKeyword)) {
    return [unknownKeyword];
  }
  let i;
  if ((i = out.findIndex(isStringKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isStringKeyword(m) && !(isLiteral(m) && typeof m.literal === "string"));
  }
  if ((i = out.findIndex(isNumberKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isNumberKeyword(m) && !(isLiteral(m) && typeof m.literal === "number"));
  }
  if ((i = out.findIndex(isBooleanKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isBooleanKeyword(m) && !(isLiteral(m) && typeof m.literal === "boolean"));
  }
  if ((i = out.findIndex(isBigIntKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isBigIntKeyword(m) && !(isLiteral(m) && typeof m.literal === "bigint"));
  }
  if ((i = out.findIndex(isSymbolKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isSymbolKeyword(m) && !isUniqueSymbol(m));
  }
  return out;
};
/** @internal */
export const getParameterBase = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
const equalsTemplateLiteralSpan = /*#__PURE__*/ReadonlyArray.getEquivalence((self, that) => self.type._tag === that.type._tag && self.literal === that.literal);
const equalsEnums = /*#__PURE__*/ReadonlyArray.getEquivalence((self, that) => that[0] === self[0] && that[1] === self[1]);
const equals = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Refinement":
    case "Tuple":
    case "TypeLiteral":
    case "Union":
    case "Suspend":
    case "Transform":
    case "Declaration":
      return self === that;
  }
};
const intersection = /*#__PURE__*/ReadonlyArray.intersectionWith(equals);
const _keyof = ast => {
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map(p => Predicate.isSymbol(p.name) ? createUniqueSymbol(p.name) : createLiteral(p.name)).concat(ast.indexSignatures.map(is => getParameterBase(is.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast) => intersection(out, _keyof(ast)), _keyof(ast.types[0]));
    case "Transform":
      return _keyof(ast.to);
  }
  throw new Error(`keyof: unsupported schema (${format(ast)})`);
};
/** @internal */
export const compose = (ab, cd) => createTransform(ab, cd, composeTransformation);
/** @internal */
export const rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral":
      {
        const propertySignatureTransforms = [];
        for (const key of Internal.ownKeys(mapping)) {
          const name = mapping[key];
          if (name !== undefined) {
            propertySignatureTransforms.push(createPropertySignatureTransform(key, name, createFinalPropertySignatureTransformation(identity, identity)));
          }
        }
        if (propertySignatureTransforms.length === 0) {
          return ast;
        }
        return createTransform(ast, createTypeLiteral(ast.propertySignatures.map(ps => {
          const name = mapping[ps.name];
          return createPropertySignature(name === undefined ? ps.name : name, to(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
        }), ast.indexSignatures), createTypeLiteralTransformation(propertySignatureTransforms));
      }
    case "Suspend":
      return createSuspend(() => rename(ast.f(), mapping));
    case "Transform":
      return compose(ast, rename(to(ast), mapping));
  }
  throw new Error(`rename: cannot rename (${format(ast)})`);
};
const formatTransformation = (from, to) => `(${from} <-> ${to})`;
/**
 * @category formatting
 * @since 1.0.0
 */
export const format = (ast, verbose = false) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
    case "AnyKeyword":
    case "UnknownKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
      return Option.getOrElse(getExpected(ast, verbose), () => ast._tag);
    case "Literal":
      return Option.getOrElse(getExpected(ast, verbose), () => formatUnknown(ast.literal));
    case "UniqueSymbol":
      return Option.getOrElse(getExpected(ast, verbose), () => formatUnknown(ast.symbol));
    case "Union":
      return Option.getOrElse(getExpected(ast, verbose), () => ast.types.map(member => format(member)).join(" | "));
    case "TemplateLiteral":
      return Option.getOrElse(getExpected(ast, verbose), () => formatTemplateLiteral(ast));
    case "Tuple":
      return Option.getOrElse(getExpected(ast, verbose), () => formatTuple(ast));
    case "TypeLiteral":
      return Option.getOrElse(getExpected(ast, verbose), () => formatTypeLiteral(ast));
    case "Enums":
      return Option.getOrElse(getExpected(ast, verbose), () => `<enum ${ast.enums.length} value(s): ${ast.enums.map((_, value) => JSON.stringify(value)).join(" | ")}>`);
    case "Suspend":
      return getExpected(ast, verbose).pipe(Option.orElse(() => Option.flatMap(Option.liftThrowable(ast.f)(), ast => getExpected(ast, verbose))), Option.getOrElse(() => "<suspended schema>"));
    case "Declaration":
      return Option.getOrElse(getExpected(ast, verbose), () => "<declaration schema>");
    case "Refinement":
      return Option.getOrElse(getExpected(ast, verbose), () => "<refinement schema>");
    case "Transform":
      return Option.getOrElse(getExpected(ast, verbose), () => formatTransformation(format(ast.from), format(ast.to)));
  }
};
/** @internal */
export const formatUnknown = u => {
  if (Predicate.isString(u)) {
    return JSON.stringify(u);
  } else if (Predicate.isNumber(u) || u == null || Predicate.isBoolean(u) || Predicate.isSymbol(u) || Predicate.isDate(u)) {
    return String(u);
  } else if (Predicate.isBigInt(u)) {
    return String(u) + "n";
  } else if (!Array.isArray(u) && Predicate.hasProperty(u, "toString") && Predicate.isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  try {
    return JSON.stringify(u);
  } catch (e) {
    return String(u);
  }
};
const formatTemplateLiteral = ast => "`" + ast.head + ast.spans.map(span => formatTemplateLiteralSpan(span) + span.literal).join("") + "`";
const getExpected = (ast, verbose) => {
  if (verbose) {
    const description = getDescriptionAnnotation(ast).pipe(Option.orElse(() => getTitleAnnotation(ast)));
    return Option.match(getIdentifierAnnotation(ast), {
      onNone: () => description,
      onSome: identifier => Option.match(description, {
        onNone: () => Option.some(identifier),
        onSome: description => Option.some(`${identifier} (${description})`)
      })
    });
  }
  return getIdentifierAnnotation(ast).pipe(Option.orElse(() => getTitleAnnotation(ast)), Option.orElse(() => getDescriptionAnnotation(ast)));
};
const formatTuple = ast => {
  const formattedElements = ast.elements.map(element => format(element.type) + (element.isOptional ? "?" : "")).join(", ");
  return Option.match(ast.rest, {
    onNone: () => "readonly [" + formattedElements + "]",
    onSome: ([head, ...tail]) => {
      const formattedHead = format(head);
      const wrappedHead = formattedHead.includes(" | ") ? "(" + formattedHead + ")" : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(ast => format(ast)).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
const formatTypeLiteral = ast => {
  const formattedPropertySignatures = ast.propertySignatures.map(ps => String(ps.name) + (ps.isOptional ? "?" : "") + ": " + format(ps.type)).join("; ");
  if (ast.indexSignatures.length > 0) {
    const formattedIndexSignatures = ast.indexSignatures.map(is => `[x: ${format(getParameterBase(is.parameter))}]: ${format(is.type)}`).join("; ");
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures}; ${formattedIndexSignatures} }`;
    } else {
      return `{ ${formattedIndexSignatures} }`;
    }
  } else {
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures} }`;
    } else {
      return "{}";
    }
  }
};
const formatTemplateLiteralSpan = span => {
  switch (span.type._tag) {
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
  }
};
//# sourceMappingURL=AST.js.map