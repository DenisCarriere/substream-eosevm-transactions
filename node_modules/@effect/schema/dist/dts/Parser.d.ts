/**
 * @since 1.0.0
 */
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import * as Option from "effect/Option";
import * as AST from "./AST.js";
import type * as ParseResult from "./ParseResult.js";
import type * as Schema from "./Schema.js";
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<ParseResult.ParseIssue, A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseResult.ParseIssue, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => I;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<ParseResult.ParseIssue, I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseResult.ParseIssue, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<ParseResult.ParseIssue, A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseResult.ParseIssue, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<ParseResult.ParseIssue, A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validatePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validate: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseResult.ParseIssue, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const is: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => u is A;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const asserts: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => I;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<ParseResult.ParseIssue, I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseResult.ParseIssue, R>;
/**
 * @since 1.0.0"
 */
export declare const defaultParseOption: AST.ParseOptions;
//# sourceMappingURL=Parser.d.ts.map