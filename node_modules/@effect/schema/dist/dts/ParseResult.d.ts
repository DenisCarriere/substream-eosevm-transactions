/**
 * @since 1.0.0
 */
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import type { LazyArg } from "effect/Function";
import * as Inspectable from "effect/Inspectable";
import type * as Option from "effect/Option";
import type * as ReadonlyArray from "effect/ReadonlyArray";
import type * as AST from "./AST.js";
declare const ParseError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "ParseError";
} & Readonly<A>;
/**
 * @since 1.0.0
 */
export declare class ParseError extends ParseError_base<{
    readonly error: ParseIssue;
}> {
    get message(): string;
    /**
     * @since 1.0.0
     */
    toString(): string;
    /**
     * @since 1.0.0
     */
    toJSON(): {
        _id: string;
        message: string;
    };
    /**
     * @since 1.0.0
     */
    [Inspectable.NodeInspectSymbol](): {
        _id: string;
        message: string;
    };
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const parseError: (issue: ParseIssue) => ParseError;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const succeed: <A>(a: A) => Either.Either<ParseIssue, A>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const fail: (issue: ParseIssue) => Either.Either<ParseIssue, never>;
declare const _try: <A>(options: {
    try: LazyArg<A>;
    catch: (e: unknown) => ParseIssue;
}) => Either.Either<ParseIssue, A>;
export { 
/**
 * @category constructors
 * @since 1.0.0
 */
_try as try };
/**
 * `ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.
 *
 * @category model
 * @since 1.0.0
 */
export type ParseIssue = Declaration | Refinement | Tuple | TypeLiteral | Union | Transform | Type | Forbidden;
/**
 * Error that occurs when a transformation has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Transform {
    readonly _tag: "Transform";
    readonly ast: AST.Transform;
    readonly actual: unknown;
    readonly kind: "From" | "Transformation" | "To";
    readonly error: ParseIssue;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const transform: (ast: AST.Transform, actual: unknown, kind: "From" | "Transformation" | "To", error: ParseIssue) => Transform;
/**
 * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
 * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Type {
    readonly _tag: "Type";
    readonly ast: AST.AST;
    readonly actual: unknown;
    readonly message: Option.Option<string>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const type: (ast: AST.AST, actual: unknown, message?: string | undefined) => Type;
/**
 * The `Forbidden` variant of the `ParseIssue` type represents an error that occurs when an Effect is encounter but disallowed from execution.
 *
 * @category model
 * @since 1.0.0
 */
export interface Forbidden {
    readonly _tag: "Forbidden";
    readonly ast: AST.AST;
    readonly actual: unknown;
    readonly message: Option.Option<string>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const forbidden: (ast: AST.AST, actual: unknown, message?: string | undefined) => Forbidden;
/**
 * Error that occurs when a declaration has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Declaration {
    readonly _tag: "Declaration";
    readonly ast: AST.Declaration;
    readonly actual: unknown;
    readonly error: ParseIssue;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const declaration: (ast: AST.Declaration, actual: unknown, error: ParseIssue) => Declaration;
/**
 * Error that occurs when a refinement has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Refinement {
    readonly _tag: "Refinement";
    readonly ast: AST.Refinement;
    readonly actual: unknown;
    readonly kind: "From" | "Predicate";
    readonly error: ParseIssue;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const refinement: (ast: AST.Refinement<AST.AST>, actual: unknown, kind: "From" | "Predicate", error: ParseIssue) => Refinement;
/**
 * Error that occurs when an array or tuple has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Tuple {
    readonly _tag: "Tuple";
    readonly ast: AST.Tuple;
    readonly actual: unknown;
    readonly errors: ReadonlyArray.NonEmptyReadonlyArray<Index>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const tuple: (ast: AST.Tuple, actual: unknown, errors: readonly [Index, ...Index[]]) => Tuple;
/**
 * Error that occurs when a type literal or record has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface TypeLiteral {
    readonly _tag: "TypeLiteral";
    readonly ast: AST.TypeLiteral;
    readonly actual: unknown;
    readonly errors: ReadonlyArray.NonEmptyReadonlyArray<Key>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const typeLiteral: (ast: AST.TypeLiteral, actual: unknown, errors: readonly [Key, ...Key[]]) => TypeLiteral;
/**
 * The `Index` error indicates that there was an error at a specific index in an array or tuple.
 *
 * @category model
 * @since 1.0.0
 */
export interface Index {
    readonly _tag: "Index";
    readonly index: number;
    readonly error: ParseIssue | Missing | Unexpected;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const index: (index: number, error: ParseIssue | Missing | Unexpected) => Index;
/**
 * The `Key` variant of the `ParseIssue` type represents an error that occurs when a key in a type literal or record is invalid.
 *
 * @category model
 * @since 1.0.0
 */
export interface Key {
    readonly _tag: "Key";
    readonly key: PropertyKey;
    readonly error: ParseIssue | Missing | Unexpected;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const key: (key: PropertyKey, error: ParseIssue | Missing | Unexpected) => Key;
/**
 * Error that occurs when a required key or index is missing.
 *
 * @category model
 * @since 1.0.0
 */
export interface Missing {
    readonly _tag: "Missing";
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const missing: Missing;
/**
 * Error that occurs when an unexpected key or index is present.
 *
 * @category model
 * @since 1.0.0
 */
export interface Unexpected {
    readonly _tag: "Unexpected";
    readonly ast: AST.AST;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const unexpected: (ast: AST.AST) => Unexpected;
/**
 * Error that occurs when a union has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Union {
    readonly _tag: "Union";
    readonly ast: AST.Union;
    readonly actual: unknown;
    readonly errors: ReadonlyArray.NonEmptyReadonlyArray<Type | TypeLiteral | Member>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const union: (ast: AST.Union, actual: unknown, errors: readonly [TypeLiteral | Type | Member, ...(TypeLiteral | Type | Member)[]]) => Union;
/**
 * Error that occurs when a member in a union has an error.
 *
 * @category model
 * @since 1.0.0
 */
export interface Member {
    readonly _tag: "Member";
    readonly ast: AST.AST;
    readonly error: ParseIssue;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const member: (ast: AST.AST, error: ParseIssue) => Member;
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const eitherOrUndefined: <A, E, R>(self: Effect.Effect<A, E, R>) => Either.Either<E, A> | undefined;
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const flatMap: {
    <A, B, E1, R1>(f: (a: A) => Effect.Effect<B, E1, R1>): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>;
    <A_1, E_1, R_1, B_1, E1_1, R1_1>(self: Effect.Effect<A_1, E_1, R_1>, f: (a: A_1) => Effect.Effect<B_1, E1_1, R1_1>): Effect.Effect<B_1, E_1 | E1_1, R_1 | R1_1>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const map: {
    <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>;
    <A_1, E_1, R_1, B_1>(self: Effect.Effect<A_1, E_1, R_1>, f: (a: A_1) => B_1): Effect.Effect<B_1, E_1, R_1>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const mapError: {
    <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>;
    <A_1, E_1, R_1, E2_1>(self: Effect.Effect<A_1, E_1, R_1>, f: (e: E_1) => E2_1): Effect.Effect<A_1, E2_1, R_1>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const mapBoth: {
    <E, E2, A, A2>(options: {
        readonly onFailure: (e: E) => E2;
        readonly onSuccess: (a: A) => A2;
    }): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>;
    <A, E, R, E2, A2>(self: Effect.Effect<A, E, R>, options: {
        readonly onFailure: (e: E) => E2;
        readonly onSuccess: (a: A) => A2;
    }): Effect.Effect<A2, E2, R>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const orElse: {
    <E, A2, E2, R2>(f: (e: E) => Effect.Effect<A2, E2, R2>): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>;
    <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): Effect.Effect<A2 | A, E2, R2 | R>;
};
export { 
/**
 * @category decoding
 * @since 1.0.0
 */
decode, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknown, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownEither, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownPromise, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encode, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknown, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownEither, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownPromise, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownSync } from "./Parser.js";
/**
 * @since 1.0.0
 */
export type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>;
/**
 * @since 1.0.0
 */
export type DeclarationDecodeUnknown<Out, R> = (u: unknown, options: AST.ParseOptions, ast: AST.Declaration) => Effect.Effect<Out, ParseIssue, R>;
//# sourceMappingURL=ParseResult.d.ts.map