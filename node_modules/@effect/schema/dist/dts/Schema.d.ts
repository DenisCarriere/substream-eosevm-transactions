/**
 * @since 1.0.0
 */
import * as BigDecimal from "effect/BigDecimal";
import * as Brand from "effect/Brand";
import * as Cause from "effect/Cause";
import * as Chunk from "effect/Chunk";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import * as Equivalence from "effect/Equivalence";
import * as Exit from "effect/Exit";
import * as FiberId from "effect/FiberId";
import type { LazyArg } from "effect/Function";
import * as HashMap from "effect/HashMap";
import * as HashSet from "effect/HashSet";
import * as List from "effect/List";
import * as Option from "effect/Option";
import type { Pipeable } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as ReadonlyArray from "effect/ReadonlyArray";
import * as Request from "effect/Request";
import * as Secret from "effect/Secret";
import type { Covariant, Equals, Invariant, Mutable, NoInfer, Simplify } from "effect/Types";
import type { Arbitrary } from "./Arbitrary.js";
import type { ParseOptions } from "./AST.js";
import * as AST from "./AST.js";
import * as ParseResult from "./ParseResult.js";
import * as Pretty from "./Pretty.js";
import type * as Serializable from "./Serializable.js";
/**
 * @since 1.0.0
 * @category symbol
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type TypeId = typeof TypeId;
/**
 * @category model
 * @since 1.0.0
 */
export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {
    readonly ast: AST.AST;
}
/**
 * @category hashing
 * @since 1.0.0
 */
export declare const hash: <A, I, R>(schema: Schema<A, I, R>) => number;
/**
 * @category formatting
 * @since 1.0.0
 */
export declare const format: <A, I, R>(schema: Schema<A, I, R>) => string;
/**
 * @since 1.0.0
 */
export declare namespace Schema {
    /**
     * @since 1.0.0
     */
    interface Variance<A, I, R> {
        readonly [TypeId]: {
            readonly _A: Invariant<A>;
            readonly _I: Invariant<I>;
            readonly _R: Covariant<R>;
        };
    }
    /**
     * @since 1.0.0
     */
    type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never;
    /**
     * @since 1.0.0
     */
    type From<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never;
    /**
     * @since 1.0.0
     */
    type To<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never;
    /**
     * @since 1.0.0
     */
    type ToAsserts<S extends Schema<any>> = (input: unknown, options?: AST.ParseOptions) => asserts input is Schema.To<S>;
}
/**
 * @since 1.0.0
 */
export declare const from: <A, I, R>(schema: Schema<A, I, R>) => Schema<I, I, never>;
/**
 * @since 1.0.0
 */
export declare const to: <A, I, R>(schema: Schema<A, I, R>) => Schema<A, A, never>;
export { 
/**
 * @category validation
 * @since 1.0.0
 */
asserts, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeSync, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownSync, 
/**
 * @category validation
 * @since 1.0.0
 */
is, 
/**
 * @category validation
 * @since 1.0.0
 */
validateOption, 
/**
 * @category validation
 * @since 1.0.0
 */
validateSync } from "./Parser.js";
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Either.Either<ParseResult.ParseError, I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Either.Either<ParseResult.ParseError, I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Either.Either<ParseResult.ParseError, A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Either.Either<ParseResult.ParseError, A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validate: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Either.Either<ParseResult.ParseError, A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validatePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
export declare const isSchema: (u: unknown) => u is Schema<unknown, unknown, unknown>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const make: <A, I, R>(ast: AST.AST) => Schema<A, I, R>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const literal: <Literals extends readonly AST.LiteralValue[]>(...literals: Literals) => Schema<Literals[number], Literals[number], never>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const uniqueSymbol: <S extends symbol>(symbol: S, annotations?: AST.Annotations) => Schema<S, S, never>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const enums: <A extends {
    [x: string]: string | number;
}>(enums: A) => Schema<A[keyof A], A[keyof A], never>;
/**
 * @since 1.0.0
 */
export type Join<T> = T extends [infer Head, ...infer Tail] ? `${Head & (string | number | bigint | boolean | null | undefined)}${Tail extends [] ? "" : Join<Tail>}` : never;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const templateLiteral: <T extends [Schema<any, any, never>, ...Schema<any, any, never>[]]>(...[head, ...tail]: T) => Schema<Join<{ [K in keyof T]: Schema.To<T[K]>; }>, Join<{ [K in keyof T]: Schema.To<T[K]>; }>, never>;
/**
 * @since 1.0.0
 */
export interface DeclareAnnotations<P extends ReadonlyArray<any>, A> extends DocAnnotations {
    readonly message?: AST.MessageAnnotation<A>;
    readonly typeId?: AST.TypeAnnotation | {
        id: AST.TypeAnnotation;
        annotation: unknown;
    };
    readonly arbitrary?: (...arbitraries: {
        readonly [K in keyof P]: Arbitrary<P[K]>;
    }) => Arbitrary<A>;
    readonly pretty?: (...pretties: {
        readonly [K in keyof P]: Pretty.Pretty<P[K]>;
    }) => Pretty.Pretty<A>;
    readonly equivalence?: (...equivalences: {
        readonly [K in keyof P]: Equivalence.Equivalence<P[K]>;
    }) => Equivalence.Equivalence<A>;
}
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const declare: {
    <A>(is: (input: unknown) => input is A, annotations?: DeclareAnnotations<readonly [], A>): Schema<A>;
    <const P extends ReadonlyArray<Schema<any, any, any>>, R extends Schema.Context<P[number]>, I, A>(typeParameters: P, decodeUnknown: (...typeParameters: P) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, R>, encodeUnknown: (...typeParameters: P) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, R>, annotations?: DeclareAnnotations<{
        readonly [K in keyof P]: Schema.To<P[K]>;
    }, A>): Schema<A, I, Schema.Context<P[number]>>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BrandTypeId: unique symbol;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const fromBrand: <C extends Brand.Brand<string | symbol>>(constructor: Brand.Brand.Constructor<C>, options?: FilterAnnotations<Brand.Brand.Unbranded<C>> | undefined) => <R, I, A extends Brand.Brand.Unbranded<C>>(self: Schema<A, I, R>) => Schema<A & C, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const InstanceOfTypeId: unique symbol;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, options?: DeclareAnnotations<[], InstanceType<A>> | undefined) => Schema<InstanceType<A>, InstanceType<A>, never>;
declare const _undefined: Schema<undefined>;
declare const _void: Schema<void>;
declare const _null: Schema<null>;
export { 
/**
 * @category primitives
 * @since 1.0.0
 */
_null as null, 
/**
 * @category primitives
 * @since 1.0.0
 */
_undefined as undefined, 
/**
 * @category primitives
 * @since 1.0.0
 */
_void as void };
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const never: Schema<never>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const unknown: Schema<unknown>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const any: Schema<any>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const string: Schema<string>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const number: Schema<number>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const boolean: Schema<boolean>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const bigintFromSelf: Schema<bigint>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const symbolFromSelf: Schema<symbol>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const object: Schema<object>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const union: <Members extends readonly Schema<any, any, any>[]>(...members: Members) => Schema<Schema.To<Members[number]>, Schema.From<Members[number]>, Schema.Context<Members[number]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nullable: <A, I, R>(self: Schema<A, I, R>) => Schema<A | null, I | null, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const orUndefined: <A, I, R>(self: Schema<A, I, R>) => Schema<A | undefined, I | undefined, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nullish: <A, I, R>(self: Schema<A, I, R>) => Schema<A | null | undefined, I | null | undefined, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const keyof: <A, I, R>(schema: Schema<A, I, R>) => Schema<keyof A, keyof A, never>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tuple: <Elements extends readonly Schema<any, any, any>[]>(...elements: Elements) => Schema<{ readonly [K in keyof Elements]: Schema.To<Elements[K]>; }, { readonly [K_1 in keyof Elements]: Schema.From<Elements[K_1]>; }, Schema.Context<Elements[number]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const rest: <B, IB, R2>(rest: Schema<B, IB, R2>) => <A extends readonly any[], I extends readonly any[], R1>(self: Schema<A, I, R1>) => Schema<readonly [...A, ...B[]], readonly [...I, ...IB[]], R2 | R1>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const element: <B, IB, R2>(element: Schema<B, IB, R2>) => <A extends readonly any[], I extends readonly any[], R1>(self: Schema<A, I, R1>) => Schema<readonly [...A, B], readonly [...I, IB], R2 | R1>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const optionalElement: <B, IB, R2>(element: Schema<B, IB, R2>) => <A extends readonly any[], I extends readonly any[], R1>(self: Schema<A, I, R1>) => Schema<readonly [...A, B?], readonly [...I, IB?], R2 | R1>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const array: <A, I, R>(item: Schema<A, I, R>) => Schema<readonly A[], readonly I[], R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nonEmptyArray: <A, I, R>(item: Schema<A, I, R>) => Schema<readonly [A, ...A[]], readonly [I, ...I[]], R>;
/**
 * @since 1.0.0
 */
export interface PropertySignature<From, FromIsOptional, To, ToIsOptional, R = never> extends Schema.Variance<To, From, R>, Pipeable {
    readonly FromIsOptional: FromIsOptional;
    readonly ToIsOptional: ToIsOptional;
}
/**
 * @since 1.0.0
 */
export declare const propertySignatureAnnotations: (annotations: DocAnnotations) => <S extends Schema<any, any, any> | Schema<never, never, any> | PropertySignature<any, boolean, any, boolean, any> | PropertySignature<never, boolean, never, boolean, any>>(self: S) => S extends Schema<infer A, infer I, infer R> ? PropertySignature<I, false, A, false, R> : S;
/**
 * @category optional
 * @since 1.0.0
 */
export declare const optionalToRequired: <A, I, R, B>(from: Schema<A, I, R>, to: Schema<B, B, never>, decode: (o: Option.Option<A>) => B, encode: (b: B) => Option.Option<A>, annotations?: DocAnnotations) => PropertySignature<I, true, B, false, R>;
/**
 * @since 1.0.0
 */
export declare const optional: {
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly exact: true;
        readonly default: () => A;
        readonly nullable: true;
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | null, true, A, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly exact: true;
        readonly default: () => A;
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I, true, A, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly exact: true;
        readonly nullable: true;
        readonly as: "Option";
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | null, true, Option.Option<A>, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly exact: true;
        readonly as: "Option";
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I, true, Option.Option<A>, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly exact: true;
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I, true, A, true, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly default: () => A;
        readonly nullable: true;
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | null | undefined, true, A, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly nullable: true;
        readonly as: "Option";
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | undefined | null, true, Option.Option<A>, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly as: "Option";
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | undefined, true, Option.Option<A>, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options: {
        readonly default: () => A;
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | undefined, true, A, false, R>;
    <A, I, R>(schema: Schema<A, I, R>, options?: {
        readonly annotations?: DocAnnotations | undefined;
    }): PropertySignature<I | undefined, true, A | undefined, true, R>;
};
/**
 * @since 1.0.0
 */
export type FromOptionalKeys<Fields> = {
    [K in keyof Fields]: Fields[K] extends PropertySignature<any, true, any, boolean, any> | PropertySignature<never, true, never, boolean, any> ? K : never;
}[keyof Fields];
/**
 * @since 1.0.0
 */
export type ToOptionalKeys<Fields> = {
    [K in keyof Fields]: Fields[K] extends PropertySignature<any, boolean, any, true, any> | PropertySignature<never, boolean, never, true, any> ? K : never;
}[keyof Fields];
/**
 * @since 1.0.0
 */
export type StructFields = Record<PropertyKey, Schema<any, any, any> | Schema<never, never, any> | PropertySignature<any, boolean, any, boolean, any> | PropertySignature<never, boolean, never, boolean, any>>;
/**
 * @since 1.0.0
 */
export type FromStruct<Fields extends StructFields> = {
    readonly [K in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: Schema.From<Fields[K]>;
} & {
    readonly [K in FromOptionalKeys<Fields>]?: Schema.From<Fields[K]>;
};
/**
 * @since 1.0.0
 */
export type ToStruct<Fields extends StructFields> = {
    readonly [K in Exclude<keyof Fields, ToOptionalKeys<Fields>>]: Schema.To<Fields[K]>;
} & {
    readonly [K in ToOptionalKeys<Fields>]?: Schema.To<Fields[K]>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const struct: <Fields extends StructFields>(fields: Fields) => Schema<Simplify<ToStruct<Fields>>, Simplify<FromStruct<Fields>>, Schema.Context<Fields[keyof Fields]>>;
/**
 * @category struct transformations
 * @since 1.0.0
 */
export declare const pick: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <R, I extends { [K in keyof A]?: any; }>(self: Schema<A, I, R>) => Schema<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R>;
/**
 * @category struct transformations
 * @since 1.0.0
 */
export declare const omit: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <R, I extends { [K in keyof A]?: any; }>(self: Schema<A, I, R>) => Schema<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R>;
/**
 * Given a schema `Schema<A, I, R>` and a key `K`, this function extracts a specific field from the `A` type, producing a new schema that represents a transformation from the `I` type to `A[K]`.
 *
 * If the option `{ transformation: false }` is provided, the returned schema `Schema<A[K], I[K], R>` only represents the value of the field without any transformation.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.struct({
 *   column1: S.NumberFromString,
 *   column2: S.number
 * })
 *
 * // const pullOutColumn1: S.Schema<number, {
 * //     readonly column1: string;
 * //     readonly column2: number;
 * // }, never>
 * const pullOutColumn1 = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decode(S.array(pullOutColumn1))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct (no transformation)
 * // ---------------------------------------------
 *
 * // const pullOutColumn1Value: S.Schema<number, string, never>
 * const pullOutColumn1Value = mytable.pipe(S.pluck("column1", { transformation: false }))
 *
 * console.log(S.decode(S.array(pullOutColumn1Value))(["1", "2"]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 1.0.0
 */
export declare const pluck: {
    <A, K extends keyof A>(key: K, options: {
        readonly transformation: false;
    }): <I extends {
        [P in K]?: any;
    }, R>(schema: Schema<A, I, R>) => Schema<A[K], I[K], R>;
    <A, K extends keyof A>(key: K): <I, R>(schema: Schema<A, I, R>) => Schema<A[K], I, R>;
    <A, I extends {
        [P in K]?: any;
    }, R, K extends keyof A>(schema: Schema<A, I, R>, key: K, options: {
        readonly transformation: false;
    }): Schema<A[K], I[K], R>;
    <A, I, R, K extends keyof A>(schema: Schema<A, I, R>, key: K): Schema<A[K], I, R>;
};
/**
 * @category model
 * @since 1.0.0
 */
export interface BrandSchema<A extends Brand.Brand<any>, I, R> extends Schema<A, I, R>, Brand.Brand.Constructor<A> {
}
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const brand: <B extends string | symbol, A>(brand: B, options?: DocAnnotations) => <I>(self: Schema<A, I, never>) => BrandSchema<A & Brand.Brand<B>, I, never>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const partial: <A, I, R>(self: Schema<A, I, R>) => Schema<Simplify<Partial<A>>, Simplify<Partial<I>>, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const required: <A, I, R>(self: Schema<A, I, R>) => Schema<Simplify<Required<A>>, Simplify<Required<I>>, R>;
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const mutable: <A, I, R>(schema: Schema<A, I, R>) => Schema<Simplify<Mutable<A>>, Simplify<Mutable<I>>, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const record: <AK extends string | symbol, IK extends string | symbol, R1, AV, IV, R2>(key: Schema<AK, IK, R1>, value: Schema<AV, IV, R2>) => Schema<{ readonly [K in AK]: AV; }, { readonly [K_1 in IK]: IV; }, R1 | R2>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const extend: {
    <B, IB, R2>(that: Schema<B, IB, R2>): <A, I, R1>(self: Schema<A, I, R1>) => Schema<Simplify<A & B>, Simplify<I & IB>, R1 | R2>;
    <A, I, R1, B, IB, R2>(self: Schema<A, I, R1>, that: Schema<B, IB, R2>): Schema<Simplify<A & B>, Simplify<I & IB>, R1 | R2>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const compose: {
    <C, B, R2>(to: Schema<C, B, R2>): <A, R1>(from: Schema<B, A, R1>) => Schema<C, A, R1 | R2>;
    <D, C, R2>(to: Schema<D, C, R2>, options: {
        strict: false;
    }): <B, A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>;
    <B, A, R1, C, R2>(from: Schema<B, A, R1>, to: Schema<C, B, R2>): Schema<C, A, R1 | R2>;
    <A, B, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>, options: {
        strict: false;
    }): Schema<D, A, R1 | R2>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const suspend: <A, I, R>(f: () => Schema<A, I, R>, annotations?: AST.Annotations) => Schema<A, I, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare function filter<A>(f: (a: A, options: ParseOptions, self: AST.Refinement) => Option.Option<ParseResult.ParseIssue>, options?: FilterAnnotations<A>): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
export declare function filter<C extends A, B extends A, A = C>(refinement: Predicate.Refinement<A, B>, options?: FilterAnnotations<A>): <I, R>(self: Schema<C, I, R>) => Schema<C & B, I, R>;
export declare function filter<A>(predicate: Predicate.Predicate<NoInfer<A>>, options?: FilterAnnotations<NoInfer<A>>): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const transformOrFail: {
    <ToA, ToI, ToR, FromA, R3, R4>(to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA, options: ParseOptions, ast: AST.Transform) => Effect.Effect<ToI, ParseResult.ParseIssue, R3>, encode: (toI: ToI, options: ParseOptions, ast: AST.Transform) => Effect.Effect<FromA, ParseResult.ParseIssue, R4>): <FromI, FromR>(self: Schema<FromA, FromI, FromR>) => Schema<ToA, FromI, FromR | ToR | R3 | R4>;
    <ToA, ToI, ToR, FromA, R3, R4>(to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA, options: ParseOptions, ast: AST.Transform) => Effect.Effect<unknown, ParseResult.ParseIssue, R3>, encode: (toI: ToI, options: ParseOptions, ast: AST.Transform) => Effect.Effect<unknown, ParseResult.ParseIssue, R4>, options: {
        strict: false;
    }): <FromI, FromR>(self: Schema<FromA, FromI, FromR>) => Schema<ToA, FromI, FromR | ToR | R3 | R4>;
    <FromA, FromI, FromR, ToA, ToI, ToR, R3, R4>(from: Schema<FromA, FromI, FromR>, to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA, options: ParseOptions, ast: AST.Transform) => Effect.Effect<ToI, ParseResult.ParseIssue, R3>, encode: (toI: ToI, options: ParseOptions, ast: AST.Transform) => Effect.Effect<FromA, ParseResult.ParseIssue, R4>): Schema<ToA, FromI, FromR | ToR | R3 | R4>;
    <FromA, FromI, FromR, ToA, ToI, ToR, R3, R4>(from: Schema<FromA, FromI, FromR>, to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA, options: ParseOptions, ast: AST.Transform) => Effect.Effect<unknown, ParseResult.ParseIssue, R3>, encode: (toI: ToI, options: ParseOptions, ast: AST.Transform) => Effect.Effect<unknown, ParseResult.ParseIssue, R4>, options: {
        strict: false;
    }): Schema<ToA, FromI, FromR | ToR | R3 | R4>;
};
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const transform: {
    <ToA, ToI, ToR, FromA>(to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA) => ToI, encode: (toI: ToI) => FromA): <FromI, FromR>(from: Schema<FromA, FromI, FromR>) => Schema<ToA, FromI, FromR | ToR>;
    <ToA, ToI, ToR, FromA>(to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA) => unknown, encode: (toI: ToI) => unknown, options: {
        strict: false;
    }): <FromI, FromR>(from: Schema<FromA, FromI, FromR>) => Schema<ToA, FromI, FromR | ToR>;
    <FromA, FromI, FromR, ToA, ToI, ToR>(from: Schema<FromA, FromI, FromR>, to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA) => ToI, encode: (toI: ToI) => FromA): Schema<ToA, FromI, FromR | ToR>;
    <FromA, FromI, FromR, ToA, ToI, ToR>(from: Schema<FromA, FromI, FromR>, to: Schema<ToA, ToI, ToR>, decode: (fromA: FromA) => unknown, encode: (toI: ToI) => unknown, options: {
        strict: false;
    }): Schema<ToA, FromI, FromR | ToR>;
};
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const transformLiteral: <From extends AST.LiteralValue, To extends AST.LiteralValue>(from: From, to: To) => Schema<To, From, never>;
/**
 * Creates a new `Schema` which maps between corresponding literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Animal = S.transformLiterals(
 *   [0, "cat"],
 *   [1, "dog"],
 *   [2, "cow"]
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const transformLiterals: <const A extends readonly (readonly [from: AST.LiteralValue, to: AST.LiteralValue])[]>(...pairs: A) => Schema<A[number][1], A[number][0], never>;
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const attachPropertySignature: {
    <K extends PropertyKey, V extends AST.LiteralValue | symbol>(key: K, value: V, options?: DocAnnotations): <A extends object, I, R>(schema: Schema<A, I, R>) => Schema<Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
    <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, options?: DocAnnotations): Schema<Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
};
/**
 * @since 1.0.0
 */
export interface DocAnnotations extends AST.Annotations {
    readonly identifier?: AST.IdentifierAnnotation;
    readonly title?: AST.TitleAnnotation;
    readonly description?: AST.DescriptionAnnotation;
    readonly examples?: AST.ExamplesAnnotation;
    readonly default?: AST.DefaultAnnotation;
    readonly documentation?: AST.DocumentationAnnotation;
}
/**
 * @since 1.0.0
 */
export interface FilterAnnotations<A> extends DeclareAnnotations<readonly [A], A> {
    /**
     * Attaches a JSON Schema annotation to this refinement.
     *
     * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
     */
    readonly jsonSchema?: AST.JSONSchemaAnnotation;
}
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const annotations: (annotations: AST.Annotations) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const message: (message: AST.MessageAnnotation<unknown>) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const identifier: (identifier: AST.IdentifierAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const title: (title: AST.TitleAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const description: (description: AST.DescriptionAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const examples: (examples: AST.ExamplesAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
declare const _default: <A>(value: A) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
export { 
/**
 * @category annotations
 * @since 1.0.0
 */
_default as default };
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const documentation: (documentation: AST.DocumentationAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Attaches a JSON Schema annotation to a schema that represents a refinement.
 *
 * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
 *
 * @category annotations
 * @since 1.0.0
 */
export declare const jsonSchema: (jsonSchema: AST.JSONSchemaAnnotation) => <A, I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const equivalence: <A>(equivalence: Equivalence.Equivalence<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
type Rename<A, M> = {
    [K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K] : never : K]: A[K];
};
/**
 * @category renaming
 * @since 1.0.0
 */
export declare const rename: {
    <A, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(mapping: M): <I, R>(self: Schema<A, I, R>) => Schema<Simplify<Rename<A, M>>, I, R>;
    <A, I, R, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(self: Schema<A, I, R>, mapping: M): Schema<Simplify<Rename<A, M>>, I, R>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const TrimmedTypeId: unique symbol;
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const trimmed: <A extends string>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MaxLengthTypeId = typeof MaxLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const maxLength: <A extends string>(maxLength: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MinLengthTypeId = typeof MinLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const minLength: <A extends string>(minLength: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PatternTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const pattern: <A extends string>(regex: RegExp, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const StartsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const startsWith: <A extends string>(startsWith: string, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const EndsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const endsWith: <A extends string>(endsWith: string, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IncludesTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const includes: <A extends string>(searchString: string, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LowercasedTypeId: unique symbol;
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const lowercased: <A extends string>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Lowercased: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UppercasedTypeId: unique symbol;
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const uppercased: <A extends string>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Uppercased: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LengthTypeId = typeof LengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const length: <A extends string>(length: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const Char: Schema<string, string, never>;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const nonEmpty: <A extends string>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Lowercase: Schema<string>;
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Uppercase: Schema<string>;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Trimmed: Schema<string>;
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Trim: Schema<string>;
/**
 * Returns a achema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const split: (separator: string) => Schema<ReadonlyArray<string>, string>;
/**
 * @since 1.0.0
 */
export type ParseJsonOptions = {
    readonly reviver?: Parameters<typeof JSON.parse>[1];
    readonly replacer?: Parameters<typeof JSON.stringify>[1];
    readonly space?: Parameters<typeof JSON.stringify>[2];
};
/**
 * The `parseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const parseJson: {
    <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): Schema<A, string, R>;
    (options?: ParseJsonOptions): Schema<unknown, string>;
};
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const NonEmpty: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UUIDTypeId: unique symbol;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const UUID: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ULIDTypeId: unique symbol;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const ULID: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const FiniteTypeId: unique symbol;
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const finite: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanTypeId = typeof GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const greaterThan: <A extends number>(min: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanOrEqualToTypeId = typeof GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualTo: <A extends number>(min: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MultipleOfTypeId: unique symbol;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const multipleOf: <A extends number>(divisor: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type IntTypeId = typeof IntTypeId;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const int: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanTypeId = typeof LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const lessThan: <A extends number>(max: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanOrEqualToTypeId = typeof LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualTo: <A extends number>(max: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type BetweenTypeId = typeof BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const between: <A extends number>(min: number, max: number, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNaNTypeId: unique symbol;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonNaN: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const positive: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const negative: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonPositive: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonNegative: <A extends number>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 1.0.0
 */
export declare const clamp: (minimum: number, maximum: number) => <R, I, A extends number>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 1.0.0
 */
export declare const NumberFromString: Schema<number, string>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Finite: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Int: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonNaN: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Positive: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Negative: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonPositive: Schema<number>;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonNegative: Schema<number>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const JsonNumberTypeId: unique symbol;
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 1.0.0
 */
export declare const JsonNumber: Schema<number>;
/**
 * @category boolean transformations
 * @since 1.0.0
 */
export declare const Not: Schema<boolean>;
/**
 * This schema transforms a `string` into a `symbol`.
 *
 * @category symbol transformations
 * @since 1.0.0
 */
export declare const symbol: Schema<symbol, string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigintTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanBigintTypeId = typeof GreaterThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const greaterThanBigint: <A extends bigint>(min: bigint, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigintTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanOrEqualToBigintTypeId = typeof GreaterThanOrEqualToBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigint: <A extends bigint>(min: bigint, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigintTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanBigintTypeId = typeof LessThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const lessThanBigint: <A extends bigint>(max: bigint, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigintTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanOrEqualToBigintTypeId = typeof LessThanOrEqualToBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigint: <A extends bigint>(max: bigint, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigintTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type BetweenBigintTypeId = typeof BetweenBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const betweenBigint: <A extends bigint>(min: bigint, max: bigint, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const positiveBigint: <A extends bigint>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const negativeBigint: <A extends bigint>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const nonNegativeBigint: <A extends bigint>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const nonPositiveBigint: <A extends bigint>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export declare const clampBigint: (minimum: bigint, maximum: bigint) => <R, I, A extends bigint>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export declare const bigint: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const PositiveBigintFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const PositiveBigint: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NegativeBigintFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NegativeBigint: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigintFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigint: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigintFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigint: Schema<bigint, string>;
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export declare const BigintFromNumber: Schema<bigint, number>;
/**
 * @category Secret constructors
 * @since 1.0.0
 */
export declare const SecretFromSelf: Schema<Secret.Secret>;
declare const _Secret: Schema<Secret.Secret, string>;
export { 
/**
 * A schema that transforms a `string` into a `Secret`.
 *
 * @category Secret transformations
 * @since 1.0.0
 */
_Secret as Secret };
/**
 * @category Duration constructors
 * @since 1.0.0
 */
export declare const DurationFromSelf: Schema<Duration.Duration>;
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const DurationFromNanos: Schema<Duration.Duration, bigint>;
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const DurationFromMillis: Schema<Duration.Duration, number>;
declare const _Duration: Schema<Duration.Duration, readonly [seconds: number, nanos: number]>;
export { 
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
_Duration as Duration };
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const clampDuration: (minimum: Duration.DurationInput, maximum: Duration.DurationInput) => <R, I, A extends Duration.Duration>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const lessThanDuration: <A extends Duration.Duration>(max: Duration.DurationInput, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToDuration: <A extends Duration.Duration>(max: Duration.DurationInput, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const greaterThanDuration: <A extends Duration.Duration>(min: Duration.DurationInput, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToDuration: <A extends Duration.Duration>(min: Duration.DurationInput, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const betweenDuration: <A extends Duration.Duration>(minimum: Duration.DurationInput, maximum: Duration.DurationInput, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category Uint8Array constructors
 * @since 1.0.0
 */
export declare const Uint8ArrayFromSelf: Schema<Uint8Array>;
declare const _Uint8Array: Schema<Uint8Array, ReadonlyArray<number>>;
export { 
/**
 * A schema that transforms a `number` array into a `Uint8Array`.
 *
 * @category Uint8Array transformations
 * @since 1.0.0
 */
_Uint8Array as Uint8Array };
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Base64: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Base64Url: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Hex: Schema<Uint8Array, string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MinItemsTypeId = typeof MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const minItems: <A>(n: number, options?: FilterAnnotations<readonly A[]> | undefined) => <I, R>(self: Schema<readonly A[], I, R>) => Schema<readonly A[], I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MaxItemsTypeId = typeof MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const maxItems: <A>(n: number, options?: FilterAnnotations<readonly A[]> | undefined) => <I, R>(self: Schema<readonly A[], I, R>) => Schema<readonly A[], I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ItemsCountTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type ItemsCountTypeId = typeof ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const itemsCount: <A>(n: number, options?: FilterAnnotations<readonly A[]> | undefined) => <I, R>(self: Schema<readonly A[], I, R>) => Schema<readonly A[], I, R>;
/**
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const getNumberIndexedAccess: <A extends readonly any[], I extends readonly any[], R>(self: Schema<A, I, R>) => Schema<A[number], I[number], R>;
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const head: <A, I, R>(self: Schema<readonly A[], I, R>) => Schema<Option.Option<A>, I, R>;
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const headOr: {
    <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<A, I, R>;
    <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): Schema<A, I, R>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ValidDateTypeId: unique symbol;
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 1.0.0
 */
export declare const validDate: (options?: FilterAnnotations<Date>) => <I, R>(self: Schema<Date, I, R>) => Schema<Date, I, R>;
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 1.0.0
 */
export declare const DateFromSelf: Schema<Date>;
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 1.0.0
 */
export declare const ValidDateFromSelf: Schema<Date>;
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 1.0.0
 */
export declare const DateFromString: Schema<Date, string>;
declare const _Date: Schema<Date, string>;
export { 
/**
 * A schema that transforms a `string` into a **valid** `Date`, ensuring that invalid dates, such as `new Date("Invalid Date")`, are rejected.
 *
 * @category Date transformations
 * @since 1.0.0
 */
_Date as Date };
/**
 * @category Option utils
 * @since 1.0.0
 */
export type OptionFrom<I> = {
    readonly _tag: "None";
} | {
    readonly _tag: "Some";
    readonly value: I;
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const optionFromSelf: <A, I, R>(value: Schema<A, I, R>) => Schema<Option.Option<A>, Option.Option<I>, R>;
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const option: <A, I, R>(value: Schema<A, I, R>) => Schema<Option.Option<A>, OptionFrom<I>, R>;
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const optionFromNullable: <A, I, R>(value: Schema<A, I, R>) => Schema<Option.Option<A>, I | null, R>;
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const optionFromNullish: <A, I, R>(value: Schema<A, I, R>, onNoneEncoding: null | undefined) => Schema<Option.Option<A>, I | null | undefined, R>;
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const optionFromOrUndefined: <A, I, R>(value: Schema<A, I, R>) => Schema<Option.Option<A>, I | undefined, R>;
/**
 * @category Either utils
 * @since 1.0.0
 */
export type RightFrom<IA> = {
    readonly _tag: "Right";
    readonly right: IA;
};
/**
 * @category Either utils
 * @since 1.0.0
 */
export type LeftFrom<IE> = {
    readonly _tag: "Left";
    readonly left: IE;
};
/**
 * @category Either utils
 * @since 1.0.0
 */
export type EitherFrom<IE, IA> = LeftFrom<IE> | RightFrom<IA>;
/**
 * @category Either transformations
 * @since 1.0.0
 */
export declare const eitherFromSelf: <E, IE, RE, A, IA, RA>({ left, right }: {
    readonly left: Schema<E, IE, RE>;
    readonly right: Schema<A, IA, RA>;
}) => Schema<Either.Either<E, A>, Either.Either<IE, IA>, RE | RA>;
/**
 * @category Either transformations
 * @since 1.0.0
 */
export declare const either: <E, IE, R1, A, IA, R2>({ left, right }: {
    readonly left: Schema<E, IE, R1>;
    readonly right: Schema<A, IA, R2>;
}) => Schema<Either.Either<E, A>, EitherFrom<IE, IA>, R1 | R2>;
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.eitherFromUnion({ left: Schema.string, right: Schema.number })
 *
 * @category Either transformations
 * @since 1.0.0
 */
export declare const eitherFromUnion: <EA, EI, R1, AA, AI, R2>({ left, right }: {
    readonly left: Schema<EA, EI, R1>;
    readonly right: Schema<AA, AI, R2>;
}) => Schema<Either.Either<EA, AA>, EI | AI, R1 | R2>;
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
export declare const readonlyMapFromSelf: <K, IK, RK, V, IV, RV>({ key, value }: {
    readonly key: Schema<K, IK, RK>;
    readonly value: Schema<V, IV, RV>;
}) => Schema<ReadonlyMap<K, V>, ReadonlyMap<IK, IV>, RK | RV>;
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
export declare const readonlyMap: <K, IK, RK, V, IV, RV>({ key, value }: {
    readonly key: Schema<K, IK, RK>;
    readonly value: Schema<V, IV, RV>;
}) => Schema<ReadonlyMap<K, V>, readonly (readonly [IK, IV])[], RK | RV>;
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
export declare const readonlySetFromSelf: <A, I, R>(item: Schema<A, I, R>) => Schema<ReadonlySet<A>, ReadonlySet<I>, R>;
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
export declare const readonlySet: <A, I, R>(item: Schema<A, I, R>) => Schema<ReadonlySet<A>, readonly I[], R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const BigDecimalFromSelf: Schema<BigDecimal.BigDecimal>;
declare const _BigDecimal: Schema<BigDecimal.BigDecimal, string>;
export { 
/**
 * @category BigDecimal transformations
 * @since 1.0.0
 */
_BigDecimal as BigDecimal };
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const BigDecimalFromNumber: Schema<BigDecimal.BigDecimal, number>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const greaterThanBigDecimal: <A extends BigDecimal.BigDecimal>(min: BigDecimal.BigDecimal, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigDecimal: <A extends BigDecimal.BigDecimal>(min: BigDecimal.BigDecimal, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const lessThanBigDecimal: <A extends BigDecimal.BigDecimal>(max: BigDecimal.BigDecimal, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigDecimal: <A extends BigDecimal.BigDecimal>(max: BigDecimal.BigDecimal, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const positiveBigDecimal: <A extends BigDecimal.BigDecimal>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const PositiveBigDecimalFromSelf: Schema<BigDecimal.BigDecimal, BigDecimal.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const nonNegativeBigDecimal: <A extends BigDecimal.BigDecimal>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigDecimalFromSelf: Schema<BigDecimal.BigDecimal, BigDecimal.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const negativeBigDecimal: <A extends BigDecimal.BigDecimal>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NegativeBigDecimalFromSelf: Schema<BigDecimal.BigDecimal, BigDecimal.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const nonPositiveBigDecimal: <A extends BigDecimal.BigDecimal>(options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigDecimalFromSelf: Schema<BigDecimal.BigDecimal, BigDecimal.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const betweenBigDecimal: <A extends BigDecimal.BigDecimal>(minimum: BigDecimal.BigDecimal, maximum: BigDecimal.BigDecimal, options?: FilterAnnotations<A> | undefined) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const clampBigDecimal: (minimum: BigDecimal.BigDecimal, maximum: BigDecimal.BigDecimal) => <R, I, A extends BigDecimal.BigDecimal>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Negates a `BigDecimal`.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const negateBigDecimal: <R, I, A extends BigDecimal.BigDecimal>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export declare const chunkFromSelf: <A, I, R>(item: Schema<A, I, R>) => Schema<Chunk.Chunk<A>, Chunk.Chunk<I>, R>;
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export declare const chunk: <A, I, R>(item: Schema<A, I, R>) => Schema<Chunk.Chunk<A>, readonly I[], R>;
/**
 * @category Data transformations
 * @since 1.0.0
 */
export declare const dataFromSelf: <R, I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category Data transformations
 * @since 1.0.0
 */
export declare const data: <R, I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<A, I, R>) => Schema<A, I, R>;
type MissingSelfGeneric<Usage extends string, Params extends string = ""> = `Missing \`Self\` generic - use \`class Self extends ${Usage}<Self>()(${Params}{ ... })\``;
/**
 * @category classes
 * @since 1.0.0
 */
export interface Class<A, I, R, C, Self, Inherited = {}, Proto = {}> extends Schema<Self, I, R> {
    new (...args: [R] extends [never] ? [
        props: Equals<C, {}> extends true ? void | {} : C,
        disableValidation?: boolean | undefined
    ] : [
        props: Equals<C, {}> extends true ? void | {} : C,
        disableValidation: true
    ]): A & Omit<Inherited, keyof A> & Proto;
    readonly struct: Schema<A, I, R>;
    readonly extend: <Extended>() => <FieldsB extends StructFields>(fields: FieldsB) => [unknown] extends [Extended] ? MissingSelfGeneric<"Base.extend"> : Class<Simplify<Omit<A, keyof FieldsB> & ToStruct<FieldsB>>, Simplify<Omit<I, keyof FieldsB> & FromStruct<FieldsB>>, R | Schema.Context<FieldsB[keyof FieldsB]>, Simplify<Omit<C, keyof FieldsB> & ToStruct<FieldsB>>, Extended, Self, Proto>;
    readonly transformOrFail: <Transformed>() => <FieldsB extends StructFields, R2, R3>(fields: FieldsB, decode: (input: A, options: ParseOptions, ast: AST.Transform) => Effect.Effect<Omit<A, keyof FieldsB> & ToStruct<FieldsB>, ParseResult.ParseIssue, R2>, encode: (input: Simplify<Omit<A, keyof FieldsB> & ToStruct<FieldsB>>, options: ParseOptions, ast: AST.Transform) => Effect.Effect<A, ParseResult.ParseIssue, R3>) => [unknown] extends [Transformed] ? MissingSelfGeneric<"Base.transform"> : Class<Simplify<Omit<A, keyof FieldsB> & ToStruct<FieldsB>>, I, R | Schema.Context<FieldsB[keyof FieldsB]> | R2 | R3, Simplify<Omit<C, keyof FieldsB> & ToStruct<FieldsB>>, Transformed, Self, Proto>;
    readonly transformOrFailFrom: <Transformed>() => <FieldsB extends StructFields, R2, R3>(fields: FieldsB, decode: (input: I, options: ParseOptions, ast: AST.Transform) => Effect.Effect<Omit<I, keyof FieldsB> & FromStruct<FieldsB>, ParseResult.ParseIssue, R2>, encode: (input: Simplify<Omit<I, keyof FieldsB> & FromStruct<FieldsB>>, options: ParseOptions, ast: AST.Transform) => Effect.Effect<I, ParseResult.ParseIssue, R3>) => [unknown] extends [Transformed] ? MissingSelfGeneric<"Base.transformFrom"> : Class<Simplify<Omit<A, keyof FieldsB> & ToStruct<FieldsB>>, I, R | Schema.Context<FieldsB[keyof FieldsB]> | R2 | R3, Simplify<Omit<C, keyof FieldsB> & ToStruct<FieldsB>>, Transformed, Self, Proto>;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare const Class: <Self>() => <Fields extends StructFields>(fields: Fields) => [unknown] extends [Self] ? "Missing `Self` generic - use `class Self extends Class<Self>()({ ... })`" : Class<Simplify<ToStruct<Fields>>, Simplify<FromStruct<Fields>>, Schema.Context<Fields[keyof Fields]>, Simplify<ToStruct<Fields>>, Self, {}, {}>;
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedClass: <Self>() => <Tag extends string, Fields extends StructFields>(tag: Tag, fields: Fields) => [unknown] extends [Self] ? "Missing `Self` generic - use `class Self extends TaggedClass<Self>()(\"Tag\", { ... })`" : Class<Simplify<{
    readonly _tag: Tag;
} & { readonly [K in Exclude<keyof Fields, ToOptionalKeys<Fields>>]: Schema.To<Fields[K]>; } & { readonly [K_1 in ToOptionalKeys<Fields>]?: Schema.To<Fields[K_1]>; }>, Simplify<{
    readonly _tag: Tag;
} & { readonly [K_2 in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: Schema.From<Fields[K_2]>; } & { readonly [K_3 in FromOptionalKeys<Fields>]?: Schema.From<Fields[K_3]>; }>, Schema.Context<Fields[keyof Fields]>, Simplify<ToStruct<Fields>>, Self, {}, {}>;
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedError: <Self>() => <Tag extends string, Fields extends StructFields>(tag: Tag, fields: Fields) => [unknown] extends [Self] ? "Missing `Self` generic - use `class Self extends TaggedError<Self>()(\"Tag\", { ... })`" : Class<Simplify<{
    readonly _tag: Tag;
} & { readonly [K in Exclude<keyof Fields, ToOptionalKeys<Fields>>]: Schema.To<Fields[K]>; } & { readonly [K_1 in ToOptionalKeys<Fields>]?: Schema.To<Fields[K_1]>; }>, Simplify<{
    readonly _tag: Tag;
} & { readonly [K_2 in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: Schema.From<Fields[K_2]>; } & { readonly [K_3 in FromOptionalKeys<Fields>]?: Schema.From<Fields[K_3]>; }>, Schema.Context<Fields[keyof Fields]>, Simplify<ToStruct<Fields>>, Self, {}, Cause.YieldableError>;
/**
 * @category classes
 * @since 1.0.0
 */
export interface TaggedRequest<Tag extends string, R, IS, S, RR, IE, E, IA, A> extends Request.Request<A, E>, Serializable.SerializableWithResult<R, IS, S, RR, IE, E, IA, A> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare namespace TaggedRequest {
    /**
     * @category classes
     * @since 1.0.0
     */
    type Any = TaggedRequest<string, any, any, any, any, any, any, any, any> | TaggedRequest<string, any, any, any, any, never, never, any, any>;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedRequest: <Self>() => <Tag extends string, Fields extends StructFields, EA, EI, ER, AA, AI, AR>(tag: Tag, Failure: Schema<EA, EI, ER>, Success: Schema<AA, AI, AR>, fields: Fields) => [unknown] extends [Self] ? "Missing `Self` generic - use `class Self extends TaggedRequest<Self>()(\"Tag\", SuccessSchema, FailureSchema, { ... })`" : Class<Simplify<{
    readonly _tag: Tag;
} & { readonly [K in Exclude<keyof Fields, ToOptionalKeys<Fields>>]: Schema.To<Fields[K]>; } & { readonly [K_1 in ToOptionalKeys<Fields>]?: Schema.To<Fields[K_1]>; }>, Simplify<{
    readonly _tag: Tag;
} & { readonly [K_2 in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: Schema.From<Fields[K_2]>; } & { readonly [K_3 in FromOptionalKeys<Fields>]?: Schema.From<Fields[K_3]>; }>, Schema.Context<Fields[keyof Fields]>, Simplify<ToStruct<Fields>>, Self, TaggedRequest<Tag, Schema.Context<Fields[keyof Fields]>, Simplify<{
    readonly _tag: Tag;
} & { readonly [K_2 in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: Schema.From<Fields[K_2]>; } & { readonly [K_3 in FromOptionalKeys<Fields>]?: Schema.From<Fields[K_3]>; }>, Self, ER | AR, EI, EA, AI, AA>, {}>;
/**
 * @category FiberId
 * @since 1.0.0
 */
export type FiberIdFrom = {
    readonly _tag: "Composite";
    readonly left: FiberIdFrom;
    readonly right: FiberIdFrom;
} | {
    readonly _tag: "None";
} | {
    readonly _tag: "Runtime";
    readonly id: number;
    readonly startTimeMillis: number;
};
/**
 * @category FiberId constructors
 * @since 1.0.0
 */
export declare const FiberIdFromSelf: Schema<FiberId.FiberId>;
declare const _FiberId: Schema<FiberId.FiberId, FiberIdFrom>;
export { 
/**
 * @category FiberId transformations
 * @since 1.0.0
 */
_FiberId as FiberId };
/**
 * @category Cause utils
 * @since 1.0.0
 */
export type CauseFrom<E> = {
    readonly _tag: "Die";
    readonly defect: unknown;
} | {
    readonly _tag: "Empty";
} | {
    readonly _tag: "Fail";
    readonly error: E;
} | {
    readonly _tag: "Interrupt";
    readonly fiberId: FiberIdFrom;
} | {
    readonly _tag: "Parallel";
    readonly left: CauseFrom<E>;
    readonly right: CauseFrom<E>;
} | {
    readonly _tag: "Sequential";
    readonly left: CauseFrom<E>;
    readonly right: CauseFrom<E>;
};
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export declare const causeFromSelf: <A, I, R1, R2 = never>({ defect, error }: {
    readonly error: Schema<A, I, R1>;
    readonly defect?: Schema<unknown, unknown, R2> | undefined;
}) => Schema<Cause.Cause<A>, Cause.Cause<I>, R1 | R2>;
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export declare const cause: <E, EI, R1, R2 = never>({ defect, error }: {
    readonly error: Schema<E, EI, R1>;
    readonly defect?: Schema<unknown, unknown, R2> | undefined;
}) => Schema<Cause.Cause<E>, CauseFrom<EI>, R1 | R2>;
/**
 * @category Exit utils
 * @since 1.0.0
 */
export type ExitFrom<A, E> = {
    readonly _tag: "Failure";
    readonly cause: CauseFrom<E>;
} | {
    readonly _tag: "Success";
    readonly value: A;
};
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export declare const exitFromSelf: <E, IE, RE, A, IA, RA, RD = never>({ defect, failure, success }: {
    readonly failure: Schema<E, IE, RE>;
    readonly success: Schema<A, IA, RA>;
    readonly defect?: Schema<unknown, unknown, RD> | undefined;
}) => Schema<Exit.Exit<A, E>, Exit.Exit<IA, IE>, RE | RA | RD>;
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export declare const exit: <E, IE, R1, A, IA, R2, R3 = never>({ defect, failure, success }: {
    readonly failure: Schema<E, IE, R1>;
    readonly success: Schema<A, IA, R2>;
    readonly defect?: Schema<unknown, unknown, R3> | undefined;
}) => Schema<Exit.Exit<A, E>, ExitFrom<IA, IE>, R1 | R2 | R3>;
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export declare const hashSetFromSelf: <A, I, R>(item: Schema<A, I, R>) => Schema<HashSet.HashSet<A>, HashSet.HashSet<I>, R>;
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export declare const hashSet: <A, I, R>(item: Schema<A, I, R>) => Schema<HashSet.HashSet<A>, readonly I[], R>;
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export declare const hashMapFromSelf: <K, IK, RK, V, IV, RV>({ key, value }: {
    readonly key: Schema<K, IK, RK>;
    readonly value: Schema<V, IV, RV>;
}) => Schema<HashMap.HashMap<K, V>, HashMap.HashMap<IK, IV>, RK | RV>;
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export declare const hashMap: <K, IK, RK, V, IV, RV>({ key, value }: {
    readonly key: Schema<K, IK, RK>;
    readonly value: Schema<V, IV, RV>;
}) => Schema<HashMap.HashMap<K, V>, readonly (readonly [IK, IV])[], RK | RV>;
/**
 * @category List transformations
 * @since 1.0.0
 */
export declare const listFromSelf: <A, I, R>(item: Schema<A, I, R>) => Schema<List.List<A>, List.List<I>, R>;
/**
 * @category List transformations
 * @since 1.0.0
 */
export declare const list: <A, I, R>(item: Schema<A, I, R>) => Schema<List.List<A>, readonly I[], R>;
//# sourceMappingURL=Schema.d.ts.map