"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransformMessage = exports.getRefinementMessage = exports.getMessage = exports.formatTypeMessage = exports.formatIssues = exports.formatIssue = exports.formatForbiddenMessage = exports.formatError = void 0;
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Option"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./AST.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/**
 * @since 1.0.0
 */

const make = (value, forest = []) => ({
  value,
  forest
});
/**
 * @category formatting
 * @since 1.0.0
 */
const formatIssues = issues => {
  const forest = issues.map(go);
  return drawTree(forest.length === 1 ? forest[0] : make(`error(s) found`, issues.map(go)));
};
/**
 * @category formatting
 * @since 1.0.0
 */
exports.formatIssues = formatIssues;
const formatIssue = issue => formatIssues([issue]);
/**
 * @category formatting
 * @since 1.0.0
 */
exports.formatIssue = formatIssue;
const formatError = error => formatIssue(error.error);
exports.formatError = formatError;
const drawTree = tree => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
  }
  return r;
};
const formatTransformationKind = kind => {
  switch (kind) {
    case "From":
      return "From side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "To":
      return "To side transformation failure";
  }
};
const formatRefinementKind = kind => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
/** @internal */
const getMessage = (ast, actual) => {
  return AST.getMessageAnnotation(ast).pipe(Option.map(annotation => annotation(actual)));
};
/** @internal */
exports.getMessage = getMessage;
const formatTypeMessage = e => getMessage(e.ast, e.actual).pipe(Option.orElse(() => e.message), Option.getOrElse(() => `Expected ${AST.format(e.ast, true)}, actual ${AST.formatUnknown(e.actual)}`));
/** @internal */
exports.formatTypeMessage = formatTypeMessage;
const formatForbiddenMessage = e => Option.getOrElse(e.message, () => "is forbidden");
exports.formatForbiddenMessage = formatForbiddenMessage;
const getParseIsssueMessage = (issue, orElse) => {
  switch (issue._tag) {
    case "Refinement":
      return Option.orElse(getRefinementMessage(issue, issue.actual), orElse);
    case "Transform":
      return Option.orElse(getTransformMessage(issue, issue.actual), orElse);
    case "Tuple":
    case "TypeLiteral":
    case "Union":
    case "Type":
      return Option.orElse(getMessage(issue.ast, issue.actual), orElse);
  }
  return orElse();
};
/** @internal */
const getRefinementMessage = (e, actual) => {
  if (e.kind === "From") {
    return getParseIsssueMessage(e.error, () => getMessage(e.ast, actual));
  }
  return getMessage(e.ast, actual);
};
/** @internal */
exports.getRefinementMessage = getRefinementMessage;
const getTransformMessage = (e, actual) => {
  return getParseIsssueMessage(e.error, () => getMessage(e.ast, actual));
};
exports.getTransformMessage = getTransformMessage;
const go = e => {
  switch (e._tag) {
    case "Type":
      return make(formatTypeMessage(e));
    case "Forbidden":
      return make(AST.format(e.ast), [make(formatForbiddenMessage(e))]);
    case "Unexpected":
      return make(`is unexpected, expected ${AST.format(e.ast, true)}`);
    case "Missing":
      return make("is missing");
    case "Union":
      return Option.match(getMessage(e.ast, e.actual), {
        onNone: () => make(AST.format(e.ast), e.errors.map(e => {
          switch (e._tag) {
            case "Member":
              return make(`Union member`, [go(e.error)]);
            default:
              return go(e);
          }
        })),
        onSome: make
      });
    case "Tuple":
      return Option.match(getMessage(e.ast, e.actual), {
        onNone: () => make(AST.format(e.ast), e.errors.map(index => make(`[${index.index}]`, [go(index.error)]))),
        onSome: make
      });
    case "TypeLiteral":
      return Option.match(getMessage(e.ast, e.actual), {
        onNone: () => make(AST.format(e.ast), e.errors.map(key => make(`[${AST.formatUnknown(key.key)}]`, [go(key.error)]))),
        onSome: make
      });
    case "Transform":
      return Option.match(getTransformMessage(e, e.actual), {
        onNone: () => make(AST.format(e.ast), [make(formatTransformationKind(e.kind), [go(e.error)])]),
        onSome: make
      });
    case "Refinement":
      return Option.match(getRefinementMessage(e, e.actual), {
        onNone: () => make(AST.format(e.ast), [make(formatRefinementKind(e.kind), [go(e.error)])]),
        onSome: make
      });
    case "Declaration":
      return Option.match(getMessage(e.ast, e.actual), {
        onNone: () => {
          const error = e.error;
          const shouldSkipDefaultMessage = error._tag === "Type" && error.ast === e.ast;
          return shouldSkipDefaultMessage ? go(error) : make(AST.format(e.ast), [go(e.error)]);
        },
        onSome: make
      });
  }
};
//# sourceMappingURL=TreeFormatter.js.map