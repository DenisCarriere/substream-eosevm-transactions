"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8Array = exports.UUIDTypeId = exports.UUID = exports.ULIDTypeId = exports.ULID = exports.TypeId = exports.TrimmedTypeId = exports.Trimmed = exports.Trim = exports.TaggedRequest = exports.TaggedError = exports.TaggedClass = exports.StartsWithTypeId = exports.SecretFromSelf = exports.Secret = exports.PropertySignatureImpl = exports.PositiveBigintFromSelf = exports.PositiveBigint = exports.PositiveBigDecimalTypeId = exports.PositiveBigDecimalFromSelf = exports.Positive = exports.PatternTypeId = exports.NumberFromString = exports.Not = exports.NonPositiveBigintFromSelf = exports.NonPositiveBigint = exports.NonPositiveBigDecimalTypeId = exports.NonPositiveBigDecimalFromSelf = exports.NonPositive = exports.NonNegativeBigintFromSelf = exports.NonNegativeBigint = exports.NonNegativeBigDecimalTypeId = exports.NonNegativeBigDecimalFromSelf = exports.NonNegative = exports.NonNaNTypeId = exports.NonNaN = exports.NonEmpty = exports.NegativeBigintFromSelf = exports.NegativeBigint = exports.NegativeBigDecimalTypeId = exports.NegativeBigDecimalFromSelf = exports.Negative = exports.MultipleOfTypeId = exports.MinLengthTypeId = exports.MinItemsTypeId = exports.MaxLengthTypeId = exports.MaxItemsTypeId = exports.LowercasedTypeId = exports.Lowercased = exports.Lowercase = exports.LessThanTypeId = exports.LessThanOrEqualToTypeId = exports.LessThanOrEqualToDurationTypeId = exports.LessThanOrEqualToBigintTypeId = exports.LessThanOrEqualToBigDecimalTypeId = exports.LessThanDurationTypeId = exports.LessThanBigintTypeId = exports.LessThanBigDecimalTypeId = exports.LengthTypeId = exports.JsonNumberTypeId = exports.JsonNumber = exports.ItemsCountTypeId = exports.IntTypeId = exports.Int = exports.InstanceOfTypeId = exports.IncludesTypeId = exports.Hex = exports.GreaterThanTypeId = exports.GreaterThanOrEqualToTypeId = exports.GreaterThanOrEqualToDurationTypeId = exports.GreaterThanOrEqualToBigintTypeId = exports.GreaterThanOrEqualToBigDecimalTypeId = exports.GreaterThanDurationTypeId = exports.GreaterThanBigintTypeId = exports.GreaterThanBigDecimalTypeId = exports.FiniteTypeId = exports.Finite = exports.FiberIdFromSelf = exports.FiberId = exports.EndsWithTypeId = exports.DurationFromSelf = exports.DurationFromNanos = exports.DurationFromMillis = exports.Duration = exports.DateFromString = exports.DateFromSelf = exports.Date = exports.Class = exports.Char = exports.BrandTypeId = exports.BigintFromNumber = exports.BigDecimalFromSelf = exports.BigDecimalFromNumber = exports.BigDecimal = exports.BetweenTypeId = exports.BetweenDurationTypeId = exports.BetweenBigintTypeId = exports.BetweenBigDecimalTypeId = exports.Base64Url = exports.Base64 = void 0;
exports.array = exports.any = exports.annotations = exports.ValidDateTypeId = exports.ValidDateFromSelf = exports.UppercasedTypeId = exports.Uppercased = exports.Uppercase = exports.Uint8ArrayFromSelf = void 0;
Object.defineProperty(exports, "asserts", {
  enumerable: true,
  get: function () {
    return Parser.asserts;
  }
});
exports.decodeEither = exports.decode = exports.declare = exports.dataFromSelf = exports.data = exports.compose = exports.clampDuration = exports.clampBigint = exports.clampBigDecimal = exports.clamp = exports.chunkFromSelf = exports.chunk = exports.causeFromSelf = exports.cause = exports.brand = exports.boolean = exports.bigintFromSelf = exports.bigint = exports.betweenDuration = exports.betweenBigint = exports.betweenBigDecimal = exports.between = exports.attachPropertySignature = void 0;
Object.defineProperty(exports, "decodeOption", {
  enumerable: true,
  get: function () {
    return Parser.decodeOption;
  }
});
exports.decodePromise = void 0;
Object.defineProperty(exports, "decodeSync", {
  enumerable: true,
  get: function () {
    return Parser.decodeSync;
  }
});
exports.decodeUnknownEither = exports.decodeUnknown = void 0;
Object.defineProperty(exports, "decodeUnknownOption", {
  enumerable: true,
  get: function () {
    return Parser.decodeUnknownOption;
  }
});
exports.decodeUnknownPromise = void 0;
Object.defineProperty(exports, "decodeUnknownSync", {
  enumerable: true,
  get: function () {
    return Parser.decodeUnknownSync;
  }
});
exports.encodeEither = exports.encode = exports.element = exports.eitherFromUnion = exports.eitherFromSelf = exports.either = exports.documentation = exports.description = exports.default = void 0;
Object.defineProperty(exports, "encodeOption", {
  enumerable: true,
  get: function () {
    return Parser.encodeOption;
  }
});
exports.encodePromise = void 0;
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return Parser.encodeSync;
  }
});
exports.encodeUnknownEither = exports.encodeUnknown = void 0;
Object.defineProperty(exports, "encodeUnknownOption", {
  enumerable: true,
  get: function () {
    return Parser.encodeUnknownOption;
  }
});
exports.encodeUnknownPromise = void 0;
Object.defineProperty(exports, "encodeUnknownSync", {
  enumerable: true,
  get: function () {
    return Parser.encodeUnknownSync;
  }
});
exports.extend = exports.exitFromSelf = exports.exit = exports.examples = exports.equivalence = exports.enums = exports.endsWith = void 0;
exports.filter = filter;
exports.intersectUnionMembers = exports.int = exports.instanceOf = exports.includes = exports.identifier = exports.headOr = exports.head = exports.hashSetFromSelf = exports.hashSet = exports.hashMapFromSelf = exports.hashMap = exports.hash = exports.greaterThanOrEqualToDuration = exports.greaterThanOrEqualToBigint = exports.greaterThanOrEqualToBigDecimal = exports.greaterThanOrEqualTo = exports.greaterThanDuration = exports.greaterThanBigint = exports.greaterThanBigDecimal = exports.greaterThan = exports.getNumberIndexedAccess = exports.fromBrand = exports.from = exports.format = exports.finite = void 0;
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return Parser.is;
  }
});
exports.lessThanBigint = exports.lessThanBigDecimal = exports.lessThan = exports.length = exports.keyof = exports.jsonSchema = exports.itemsCount = exports.isSchema = void 0;
exports.validateEither = exports.validate = exports.validDate = exports.uppercased = exports.unknown = exports.uniqueSymbol = exports.union = exports.undefined = exports.tuple = exports.trimmed = exports.transformOrFail = exports.transformLiterals = exports.transformLiteral = exports.transform = exports.to = exports.title = exports.templateLiteral = exports.symbolFromSelf = exports.symbol = exports.suspend = exports.struct = exports.string = exports.startsWith = exports.split = exports.rest = exports.required = exports.rename = exports.record = exports.readonlySetFromSelf = exports.readonlySet = exports.readonlyMapFromSelf = exports.readonlyMap = exports.propertySignatureAnnotations = exports.positiveBigint = exports.positiveBigDecimal = exports.positive = exports.pluck = exports.pick = exports.pattern = exports.partial = exports.parseJson = exports.orUndefined = exports.optionalToRequired = exports.optionalElement = exports.optional = exports.optionFromSelf = exports.optionFromOrUndefined = exports.optionFromNullish = exports.optionFromNullable = exports.option = exports.omit = exports.object = exports.number = exports.nullish = exports.nullable = exports.null = exports.nonPositiveBigint = exports.nonPositiveBigDecimal = exports.nonPositive = exports.nonNegativeBigint = exports.nonNegativeBigDecimal = exports.nonNegative = exports.nonNaN = exports.nonEmptyArray = exports.nonEmpty = exports.never = exports.negativeBigint = exports.negativeBigDecimal = exports.negative = exports.negateBigDecimal = exports.mutable = exports.multipleOf = exports.minLength = exports.minItems = exports.message = exports.maxLength = exports.maxItems = exports.make = exports.lowercased = exports.literal = exports.listFromSelf = exports.list = exports.lessThanOrEqualToDuration = exports.lessThanOrEqualToBigint = exports.lessThanOrEqualToBigDecimal = exports.lessThanOrEqualTo = exports.lessThanDuration = void 0;
Object.defineProperty(exports, "validateOption", {
  enumerable: true,
  get: function () {
    return Parser.validateOption;
  }
});
exports.validatePromise = void 0;
Object.defineProperty(exports, "validateSync", {
  enumerable: true,
  get: function () {
    return Parser.validateSync;
  }
});
exports.void = void 0;
var BigDecimal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/BigDecimal"));
var BigInt_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/BigInt"));
var Brand = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Brand"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Cause"));
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Chunk"));
var Data = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Data"));
var Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Duration"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Effect"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Either"));
var Encoding = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Encoding"));
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Equal"));
var Equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Equivalence"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Exit"));
var FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/FiberId"));
var _Function = /*#__PURE__*/require("effect/Function");
var HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/HashMap"));
var HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/HashSet"));
var List = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/List"));
var N = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Number"));
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Option"));
var _Pipeable = /*#__PURE__*/require("effect/Pipeable");
var Predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Predicate"));
var ReadonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/ReadonlyArray"));
var Request = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Request"));
var Secret = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Secret"));
var S = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/String"));
var arbitrary = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Arbitrary.js"));
var ArrayFormatter = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./ArrayFormatter.js"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./AST.js"));
var Internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/ast.js"));
var InternalBigInt = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/bigint.js"));
var filters = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/filters.js"));
var hooks = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/hooks.js"));
var InternalSchema = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/schema.js"));
var InternalSerializable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/serializable.js"));
var Parser = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Parser.js"));
var ParseResult = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./ParseResult.js"));
var Pretty = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Pretty.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category symbol
 */
const TypeId = exports.TypeId = InternalSchema.TypeId;
/**
 * @category hashing
 * @since 1.0.0
 */
const hash = schema => AST.hash(schema.ast);
/**
 * @category formatting
 * @since 1.0.0
 */
exports.hash = hash;
const format = schema => AST.format(schema.ast);
/**
 * @since 1.0.0
 */
exports.format = format;
const from = schema => make(AST.from(schema.ast));
/**
 * @since 1.0.0
 */
exports.from = from;
const to = schema => make(AST.to(schema.ast));
/* c8 ignore start */
exports.to = to;
/* c8 ignore end */
/**
 * @category encoding
 * @since 1.0.0
 */
const encodeUnknown = (schema, options) => {
  const encodeUnknown = Parser.encodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknown = encodeUnknown;
const encodeUnknownEither = (schema, options) => {
  const encodeUnknownEither = Parser.encodeUnknownEither(schema, options);
  return (u, overrideOptions) => Either.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknownEither = encodeUnknownEither;
const encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknownPromise = encodeUnknownPromise;
const encode = exports.encode = encodeUnknown;
/**
 * @category encoding
 * @since 1.0.0
 */
const encodeEither = exports.encodeEither = encodeUnknownEither;
/**
 * @category encoding
 * @since 1.0.0
 */
const encodePromise = exports.encodePromise = encodeUnknownPromise;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodeUnknown = (schema, options) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknown = decodeUnknown;
const decodeUnknownEither = (schema, options) => {
  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options);
  return (u, overrideOptions) => Either.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknownEither = decodeUnknownEither;
const decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknownPromise = decodeUnknownPromise;
const decode = exports.decode = decodeUnknown;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodeEither = exports.decodeEither = decodeUnknownEither;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodePromise = exports.decodePromise = decodeUnknownPromise;
/**
 * @category validation
 * @since 1.0.0
 */
const validate = (schema, options) => {
  const validate = Parser.validate(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
exports.validate = validate;
const validateEither = (schema, options) => {
  const validateEither = Parser.validateEither(schema, options);
  return (u, overrideOptions) => Either.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
exports.validateEither = validateEither;
const validatePromise = (schema, options) => {
  const parser = validate(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
exports.validatePromise = validatePromise;
const isSchema = u => Predicate.isObject(u) && TypeId in u && "ast" in u;
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isSchema = isSchema;
const make = exports.make = InternalSchema.make;
const makeLiteral = value => make(AST.createLiteral(value));
/**
 * @category constructors
 * @since 1.0.0
 */
const literal = (...literals) => union(...literals.map(literal => makeLiteral(literal)));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.literal = literal;
const uniqueSymbol = (symbol, annotations) => make(AST.createUniqueSymbol(symbol, annotations));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.uniqueSymbol = uniqueSymbol;
const enums = enums => make(AST.createEnums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]])));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.enums = enums;
const templateLiteral = (...[head, ...tail]) => {
  let types = getTemplateLiterals(head.ast);
  for (const span of tail) {
    types = ReadonlyArray.flatMap(types, a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b)));
  }
  return make(AST.createUnion(types));
};
exports.templateLiteral = templateLiteral;
const combineTemplateLiterals = (a, b) => {
  if (AST.isLiteral(a)) {
    return AST.isLiteral(b) ? AST.createLiteral(String(a.literal) + String(b.literal)) : AST.createTemplateLiteral(String(a.literal) + b.head, b.spans);
  }
  if (AST.isLiteral(b)) {
    return AST.createTemplateLiteral(a.head, ReadonlyArray.modifyNonEmptyLast(a.spans, span => ({
      ...span,
      literal: span.literal + String(b.literal)
    })));
  }
  return AST.createTemplateLiteral(a.head, ReadonlyArray.appendAll(ReadonlyArray.modifyNonEmptyLast(a.spans, span => ({
    ...span,
    literal: span.literal + String(b.head)
  })), b.spans));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [ast];
    case "NumberKeyword":
    case "StringKeyword":
      return [AST.createTemplateLiteral("", [{
        type: ast,
        literal: ""
      }])];
    case "Union":
      return ReadonlyArray.flatMap(ast.types, getTemplateLiterals);
    default:
      throw new Error(`templateLiteral: unsupported template literal span (${AST.format(ast)})`);
  }
};
const declareConstructor = (typeParameters, decodeUnknown, encodeUnknown, annotations) => make(AST.createDeclaration(typeParameters.map(tp => tp.ast), (...typeParameters) => decodeUnknown(...typeParameters.map(ast => make(ast))), (...typeParameters) => encodeUnknown(...typeParameters.map(ast => make(ast))), toAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? ParseResult.succeed(input) : ParseResult.fail(ParseResult.type(ast, input));
  const encodeUnknown = decodeUnknown;
  return make(AST.createDeclaration([], decodeUnknown, encodeUnknown, toAnnotations(annotations)));
};
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 1.0.0
 */
const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const decodeUnknown = arguments[1];
    const encodeUnknown = arguments[2];
    const annotations = arguments[3];
    return declareConstructor(typeParameters, decodeUnknown, encodeUnknown, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.declare = declare;
const BrandTypeId = exports.BrandTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Brand");
/**
 * @category constructors
 * @since 1.0.0
 */
const fromBrand = (constructor, options) => self => {
  return make(AST.createRefinement(self.ast, (a, _, ast) => {
    const either = constructor.either(a);
    return Either.isLeft(either) ? Option.some(ParseResult.type(ast, a, either.left.map(v => v.message).join(", "))) : Option.none();
  }, toAnnotations({
    typeId: {
      id: BrandTypeId,
      annotation: {
        constructor
      }
    },
    ...options
  })));
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.fromBrand = fromBrand;
const InstanceOfTypeId = exports.InstanceOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/InstanceOf");
/**
 * @category constructors
 * @since 1.0.0
 */
const instanceOf = (constructor, options) => declare(u => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  typeId: {
    id: InstanceOfTypeId,
    annotation: {
      constructor
    }
  },
  ...options
});
exports.instanceOf = instanceOf;
const _undefined = exports.undefined = /*#__PURE__*/make(AST.undefinedKeyword);
const _void = exports.void = /*#__PURE__*/make(AST.voidKeyword);
const _null = exports.null = /*#__PURE__*/make(AST._null);
/**
 * @category primitives
 * @since 1.0.0
 */
const never = exports.never = /*#__PURE__*/make(AST.neverKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const unknown = exports.unknown = /*#__PURE__*/make(AST.unknownKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const any = exports.any = /*#__PURE__*/make(AST.anyKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const string = exports.string = /*#__PURE__*/make(AST.stringKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const number = exports.number = /*#__PURE__*/make(AST.numberKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const boolean = exports.boolean = /*#__PURE__*/make(AST.booleanKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const bigintFromSelf = exports.bigintFromSelf = /*#__PURE__*/make(AST.bigIntKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const symbolFromSelf = exports.symbolFromSelf = /*#__PURE__*/make(AST.symbolKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const object = exports.object = /*#__PURE__*/make(AST.objectKeyword);
/**
 * @category combinators
 * @since 1.0.0
 */
const union = (...members) => make(AST.createUnion(members.map(m => m.ast)));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.union = union;
const nullable = self => union(_null, self);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.nullable = nullable;
const orUndefined = self => union(_undefined, self);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.orUndefined = orUndefined;
const nullish = self => union(_null, _undefined, self);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.nullish = nullish;
const keyof = schema => make(AST.keyof(schema.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.keyof = keyof;
const tuple = (...elements) => make(AST.createTuple(elements.map(schema => AST.createElement(schema.ast, false)), Option.none(), true));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.tuple = tuple;
const rest = rest => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendRestElement(self.ast, rest.ast));
  }
  throw new Error("`rest` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.rest = rest;
const element = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, false)));
  }
  throw new Error("`element` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.element = element;
const optionalElement = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, true)));
  }
  throw new Error("`optionalElement` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.optionalElement = optionalElement;
const array = item => make(AST.createTuple([], Option.some([item.ast]), true));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.array = array;
const nonEmptyArray = item => tuple(item).pipe(rest(item));
/** @internal */
exports.nonEmptyArray = nonEmptyArray;
class PropertySignatureImpl {
  propertySignatureAST;
  [TypeId] = InternalSchema.variance;
  FromIsOptional;
  ToIsOptional;
  constructor(propertySignatureAST) {
    this.propertySignatureAST = propertySignatureAST;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/**
 * @since 1.0.0
 */
exports.PropertySignatureImpl = PropertySignatureImpl;
const propertySignatureAnnotations = annotations => self => {
  if (isSchema(self)) {
    return new PropertySignatureImpl({
      _tag: "Declaration",
      from: self.ast,
      isOptional: false,
      annotations: toAnnotations(annotations)
    });
  }
  return new PropertySignatureImpl({
    ...self.propertySignatureAST,
    annotations: toAnnotations(annotations)
  });
};
/**
 * @category optional
 * @since 1.0.0
 */
exports.propertySignatureAnnotations = propertySignatureAnnotations;
const optionalToRequired = (from, to, decode,
// `none` here means: the value is missing in the input
encode,
// `none` here means: the value will be missing in the output
annotations) => new PropertySignatureImpl({
  _tag: "OptionalToRequired",
  from: from.ast,
  to: to.ast,
  decode: o => Option.some(decode(o)),
  encode: Option.flatMap(encode),
  annotations: toAnnotations(annotations)
});
/**
 * @since 1.0.0
 */
exports.optionalToRequired = optionalToRequired;
const optional = (schema, options) => {
  const isExact = options?.exact;
  const value = options?.default;
  const isNullable = options?.nullable;
  const asOption = options?.as == "Option";
  const annotations = options?.annotations;
  if (isExact) {
    if (value) {
      if (isNullable) {
        return optionalToRequired(nullable(schema), to(schema), Option.match({
          onNone: value,
          onSome: a => a === null ? value() : a
        }), Option.some, annotations);
      } else {
        return optionalToRequired(schema, to(schema), Option.match({
          onNone: value,
          onSome: _Function.identity
        }), Option.some, annotations);
      }
    } else {
      if (asOption) {
        if (isNullable) {
          return optionalToRequired(nullable(schema), optionFromSelf(to(schema)), Option.filter(Predicate.isNotNull), _Function.identity, annotations);
        } else {
          return optionalToRequired(schema, optionFromSelf(to(schema)), _Function.identity, _Function.identity, annotations);
        }
      }
      return new PropertySignatureImpl({
        _tag: "Declaration",
        from: schema.ast,
        isOptional: true,
        annotations: toAnnotations(annotations)
      });
    }
  } else {
    if (value) {
      if (isNullable) {
        return optionalToRequired(nullish(schema), to(schema), Option.match({
          onNone: value,
          onSome: a => a == null ? value() : a
        }), Option.some, annotations);
      } else {
        return optionalToRequired(orUndefined(schema), to(schema), Option.match({
          onNone: value,
          onSome: a => a === undefined ? value() : a
        }), Option.some, annotations);
      }
    } else {
      if (asOption) {
        if (isNullable) {
          return optionalToRequired(nullish(schema), optionFromSelf(to(schema)), Option.filter(a => a != null), _Function.identity, annotations);
        } else {
          return optionalToRequired(orUndefined(schema), optionFromSelf(to(schema)), Option.filter(Predicate.isNotUndefined), _Function.identity, annotations);
        }
      }
      return new PropertySignatureImpl({
        _tag: "Declaration",
        from: orUndefined(schema).ast,
        isOptional: true,
        annotations: toAnnotations(annotations)
      });
    }
  }
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.optional = optional;
const struct = fields => {
  const ownKeys = Internal.ownKeys(fields);
  const pss = [];
  const pssFrom = [];
  const pssTo = [];
  const psTransformations = [];
  for (let i = 0; i < ownKeys.length; i++) {
    const key = ownKeys[i];
    const field = fields[key];
    if ("propertySignatureAST" in field) {
      const psAst = field.propertySignatureAST;
      const from = psAst.from;
      const annotations = psAst.annotations;
      switch (psAst._tag) {
        case "Declaration":
          pss.push(AST.createPropertySignature(key, from, psAst.isOptional, true, annotations));
          pssFrom.push(AST.createPropertySignature(key, from, psAst.isOptional, true));
          pssTo.push(AST.createPropertySignature(key, AST.to(from), psAst.isOptional, true, annotations));
          break;
        case "OptionalToRequired":
          pssFrom.push(AST.createPropertySignature(key, from, true, true));
          pssTo.push(AST.createPropertySignature(key, psAst.to, false, true, annotations));
          psTransformations.push(AST.createPropertySignatureTransform(key, key, AST.createFinalPropertySignatureTransformation(psAst.decode, psAst.encode)));
          break;
      }
    } else {
      pss.push(AST.createPropertySignature(key, field.ast, false, true));
      pssFrom.push(AST.createPropertySignature(key, field.ast, false, true));
      pssTo.push(AST.createPropertySignature(key, AST.to(field.ast), false, true));
    }
  }
  if (ReadonlyArray.isNonEmptyReadonlyArray(psTransformations)) {
    return make(AST.createTransform(AST.createTypeLiteral(pssFrom, []), AST.createTypeLiteral(pssTo, []), AST.createTypeLiteralTransformation(psTransformations)));
  }
  return make(AST.createTypeLiteral(pss, []));
};
/**
 * @category struct transformations
 * @since 1.0.0
 */
exports.struct = struct;
const pick = (...keys) => self => {
  const ast = self.ast;
  if (AST.isTransform(ast)) {
    if (AST.isTypeLiteralTransformation(ast.transformation)) {
      const propertySignatureTransformations = ast.transformation.propertySignatureTransformations.filter(t => keys.includes(t.to));
      if (ReadonlyArray.isNonEmptyReadonlyArray(propertySignatureTransformations)) {
        return make(AST.createTransform(AST.pick(ast.from, keys), AST.pick(ast.to, keys), AST.createTypeLiteralTransformation(propertySignatureTransformations)));
      } else {
        return make(AST.pick(ast.from, keys));
      }
    }
    throw new Error(`pick: cannot handle this kind of transformation`);
  }
  return make(AST.pick(ast, keys));
};
/**
 * @category struct transformations
 * @since 1.0.0
 */
exports.pick = pick;
const omit = (...keys) => self => {
  const ast = self.ast;
  if (AST.isTransform(ast)) {
    if (AST.isTypeLiteralTransformation(ast.transformation)) {
      const propertySignatureTransformations = ast.transformation.propertySignatureTransformations.filter(t => !keys.includes(t.to));
      if (ReadonlyArray.isNonEmptyReadonlyArray(propertySignatureTransformations)) {
        return make(AST.createTransform(AST.omit(ast.from, keys), AST.omit(ast.to, keys), AST.createTypeLiteralTransformation(propertySignatureTransformations)));
      } else {
        return make(AST.omit(ast.from, keys));
      }
    }
    throw new Error(`omit: cannot handle this kind of transformation`);
  }
  return make(AST.omit(ast, keys));
};
/**
 * Given a schema `Schema<A, I, R>` and a key `K`, this function extracts a specific field from the `A` type, producing a new schema that represents a transformation from the `I` type to `A[K]`.
 *
 * If the option `{ transformation: false }` is provided, the returned schema `Schema<A[K], I[K], R>` only represents the value of the field without any transformation.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.struct({
 *   column1: S.NumberFromString,
 *   column2: S.number
 * })
 *
 * // const pullOutColumn1: S.Schema<number, {
 * //     readonly column1: string;
 * //     readonly column2: number;
 * // }, never>
 * const pullOutColumn1 = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decode(S.array(pullOutColumn1))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct (no transformation)
 * // ---------------------------------------------
 *
 * // const pullOutColumn1Value: S.Schema<number, string, never>
 * const pullOutColumn1Value = mytable.pipe(S.pluck("column1", { transformation: false }))
 *
 * console.log(S.decode(S.array(pullOutColumn1Value))(["1", "2"]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 1.0.0
 */
exports.omit = omit;
const pluck = exports.pluck = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (schema, key, options) => {
  if (options && options.transformation == false) {
    const ps = AST.getPropertyKeyIndexedAccess(schema.ast, key);
    return make(ps.isOptional ? AST.createUnion([AST.undefinedKeyword, ps.type]) : ps.type);
  } else {
    const ps = AST.getPropertyKeyIndexedAccess(to(schema).ast, key);
    const value = make(ps.isOptional ? AST.createUnion([AST.undefinedKeyword, ps.type]) : ps.type);
    return transform(schema, value, a => a[key], ak => ps.isOptional && ak === undefined ? {} : {
      [key]: ak
    });
  }
});
const appendBrandAnnotation = (ast, brand, options) => {
  const annotations = toAnnotations(options);
  const brands = ast.annotations[AST.BrandAnnotationId];
  annotations[AST.BrandAnnotationId] = brands ? [...brands, brand] : [brand];
  return AST.mergeAnnotations(ast, annotations);
};
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
const brand = (brand, options) => self => {
  const ast = appendBrandAnnotation(self.ast, brand, options);
  const schema = make(ast);
  const validateSync = Parser.validateSync(schema);
  const validateOption = Parser.validateOption(schema);
  const _validateEither = validateEither(schema);
  const is = Parser.is(schema);
  const out = Object.assign(input => validateSync(input), {
    [Brand.RefinedConstructorsTypeId]: Brand.RefinedConstructorsTypeId,
    [TypeId]: InternalSchema.variance,
    ast,
    option: input => validateOption(input),
    either: input => Either.mapLeft(_validateEither(input), e => ArrayFormatter.formatError(e).map(err => ({
      meta: err.path,
      message: err.message
    }))),
    is: input => is(input),
    pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
  });
  return out;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.brand = brand;
const partial = self => make(AST.partial(self.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.partial = partial;
const required = self => make(AST.required(self.ast));
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 1.0.0
 */
exports.required = required;
const mutable = schema => {
  const ast = AST.mutable(schema.ast);
  return ast === schema.ast ? schema : make(ast);
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.mutable = mutable;
const record = (key, value) => make(AST.createRecord(key.ast, value.ast, true));
/** @internal */
exports.record = record;
const intersectUnionMembers = (xs, ys) => {
  return AST.createUnion(xs.flatMap(x => {
    return ys.map(y => {
      if (AST.isTypeLiteral(x)) {
        if (AST.isTypeLiteral(y)) {
          // isTypeLiteral(x) && isTypeLiteral(y)
          return AST.createTypeLiteral(x.propertySignatures.concat(y.propertySignatures), x.indexSignatures.concat(y.indexSignatures));
        } else if (AST.isTransform(y) && AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteral(y.from) && AST.isTypeLiteral(y.to)) {
          // isTypeLiteral(x) && isTransform(y)
          const from = AST.createTypeLiteral(x.propertySignatures.concat(y.from.propertySignatures), x.indexSignatures.concat(y.from.indexSignatures));
          const to = AST.createTypeLiteral(AST.getToPropertySignatures(x.propertySignatures).concat(y.to.propertySignatures), AST.getToIndexSignatures(x.indexSignatures).concat(y.to.indexSignatures));
          return AST.createTransform(from, to, AST.createTypeLiteralTransformation(y.transformation.propertySignatureTransformations));
        }
      } else if (AST.isTransform(x) && AST.isTypeLiteralTransformation(x.transformation) && AST.isTypeLiteral(x.from) && AST.isTypeLiteral(x.to)) {
        if (AST.isTypeLiteral(y)) {
          // isTransform(x) && isTypeLiteral(y)
          const from = AST.createTypeLiteral(x.from.propertySignatures.concat(y.propertySignatures), x.from.indexSignatures.concat(y.indexSignatures));
          const to = AST.createTypeLiteral(x.to.propertySignatures.concat(AST.getToPropertySignatures(y.propertySignatures)), x.to.indexSignatures.concat(AST.getToIndexSignatures(y.indexSignatures)));
          return AST.createTransform(from, to, AST.createTypeLiteralTransformation(x.transformation.propertySignatureTransformations));
        } else if (AST.isTransform(y) && AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteral(y.from) && AST.isTypeLiteral(y.to)) {
          // isTransform(x) && isTransform(y)
          const from = AST.createTypeLiteral(x.from.propertySignatures.concat(y.from.propertySignatures), x.from.indexSignatures.concat(y.from.indexSignatures));
          const to = AST.createTypeLiteral(x.to.propertySignatures.concat(y.to.propertySignatures), x.to.indexSignatures.concat(y.to.indexSignatures));
          return AST.createTransform(from, to, AST.createTypeLiteralTransformation(x.transformation.propertySignatureTransformations.concat(y.transformation.propertySignatureTransformations)));
        }
      }
      throw new Error("`extend` can only handle type literals or unions of type literals");
    });
  }));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.intersectUnionMembers = intersectUnionMembers;
const extend = exports.extend = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(intersectUnionMembers(AST.isUnion(self.ast) ? self.ast.types : [self.ast], AST.isUnion(that.ast) ? that.ast.types : [that.ast])));
/**
 * @category combinators
 * @since 1.0.0
 */
const compose = exports.compose = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[1]), (from, to) => make(AST.compose(from.ast, to.ast)));
/**
 * @category combinators
 * @since 1.0.0
 */
const suspend = (f, annotations) => make(AST.createSuspend(() => f().ast, annotations));
exports.suspend = suspend;
function filter(predicate, options) {
  return self => make(AST.createRefinement(self.ast, (a, options, ast) => {
    const out = predicate(a, options, ast);
    if (Predicate.isBoolean(out)) {
      return out ? Option.none() : Option.some(ParseResult.type(ast, a));
    }
    return out;
  }, toAnnotations(options)));
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 1.0.0
 */
const transformOrFail = exports.transformOrFail = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, decode, encode) => make(AST.createTransform(from.ast, to.ast, AST.createFinalTransformation(decode, encode))));
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 1.0.0
 */
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, decode, encode) => transformOrFail(from, to, fromA => ParseResult.succeed(decode(fromA)), toI => ParseResult.succeed(encode(toI))));
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 1.0.0
 */
const transformLiteral = (from, to) => transform(literal(from), literal(to), () => to, () => from);
/**
 * Creates a new `Schema` which maps between corresponding literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Animal = S.transformLiterals(
 *   [0, "cat"],
 *   [1, "dog"],
 *   [2, "cow"]
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
 *
 * @category constructors
 * @since 1.0.0
 */
exports.transformLiteral = transformLiteral;
const transformLiterals = (...pairs) => union(...pairs.map(([from, to]) => transformLiteral(from, to)));
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
exports.transformLiterals = transformLiterals;
const attachPropertySignature = exports.attachPropertySignature = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (schema, key, value, options) => {
  const attached = extend(to(schema), struct({
    [key]: Predicate.isSymbol(value) ? uniqueSymbol(value) : literal(value)
  })).ast;
  return make(AST.createTransform(schema.ast, options ? AST.mergeAnnotations(attached, toAnnotations(options)) : attached, AST.createTypeLiteralTransformation([AST.createPropertySignatureTransform(key, key, AST.createFinalPropertySignatureTransformation(() => Option.some(value), () => Option.none()))])));
});
const toAnnotations = options => {
  if (!options) {
    return {};
  }
  const out = {};
  // symbols are reserved for custom annotations
  const custom = Object.getOwnPropertySymbols(options);
  for (const sym of custom) {
    out[sym] = options[sym];
  }
  // string keys are reserved as /schema namespace
  if (options.typeId !== undefined) {
    const typeId = options.typeId;
    if (typeof typeId === "object") {
      out[AST.TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[AST.TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (options[from] !== undefined) {
      out[to] = options[from];
    }
  };
  move("message", AST.MessageAnnotationId);
  move("identifier", AST.IdentifierAnnotationId);
  move("title", AST.TitleAnnotationId);
  move("description", AST.DescriptionAnnotationId);
  move("examples", AST.ExamplesAnnotationId);
  move("default", AST.DefaultAnnotationId);
  move("documentation", AST.DocumentationAnnotationId);
  move("jsonSchema", AST.JSONSchemaAnnotationId);
  move("arbitrary", hooks.ArbitraryHookId);
  move("pretty", hooks.PrettyHookId);
  move("equivalence", hooks.EquivalenceHookId);
  return out;
};
/**
 * @category annotations
 * @since 1.0.0
 */
const annotations = annotations => self => make(AST.mergeAnnotations(self.ast, annotations));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.annotations = annotations;
const message = message => self => make(AST.setAnnotation(self.ast, AST.MessageAnnotationId, message));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.message = message;
const identifier = identifier => self => make(AST.setAnnotation(self.ast, AST.IdentifierAnnotationId, identifier));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.identifier = identifier;
const title = title => self => make(AST.setAnnotation(self.ast, AST.TitleAnnotationId, title));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.title = title;
const description = description => self => make(AST.setAnnotation(self.ast, AST.DescriptionAnnotationId, description));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.description = description;
const examples = examples => self => make(AST.setAnnotation(self.ast, AST.ExamplesAnnotationId, examples));
exports.examples = examples;
const _default = value => self => make(AST.setAnnotation(self.ast, AST.DefaultAnnotationId, value));
exports.default = _default;
/**
 * @category annotations
 * @since 1.0.0
 */
const documentation = documentation => self => make(AST.setAnnotation(self.ast, AST.DocumentationAnnotationId, documentation));
/**
 * Attaches a JSON Schema annotation to a schema that represents a refinement.
 *
 * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
 *
 * @category annotations
 * @since 1.0.0
 */
exports.documentation = documentation;
const jsonSchema = jsonSchema => self => make(AST.setAnnotation(self.ast, AST.JSONSchemaAnnotationId, jsonSchema));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.jsonSchema = jsonSchema;
const equivalence = equivalence => self => make(AST.setAnnotation(self.ast, hooks.EquivalenceHookId, () => equivalence));
/**
 * @category renaming
 * @since 1.0.0
 */
exports.equivalence = equivalence;
const rename = exports.rename = /*#__PURE__*/(0, _Function.dual)(2, (self, mapping) => {
  return make(AST.rename(self.ast, mapping));
});
/**
 * @category type id
 * @since 1.0.0
 */
const TrimmedTypeId = exports.TrimmedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Trimmed");
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 1.0.0
 */
const trimmed = options => self => self.pipe(filter(a => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.trimmed = trimmed;
const MaxLengthTypeId = exports.MaxLengthTypeId = filters.MaxLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const maxLength = (maxLength, options) => self => self.pipe(filter(a => a.length <= maxLength, {
  typeId: MaxLengthTypeId,
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxLength = maxLength;
const MinLengthTypeId = exports.MinLengthTypeId = filters.MinLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const minLength = (minLength, options) => self => self.pipe(filter(a => a.length >= minLength, {
  typeId: MinLengthTypeId,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minLength = minLength;
const PatternTypeId = exports.PatternTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Pattern");
/**
 * @category string filters
 * @since 1.0.0
 */
const pattern = (regex, options) => self => {
  const pattern = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    arbitrary: () => fc => fc.stringMatching(regex),
    ...options
  }));
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.pattern = pattern;
const StartsWithTypeId = exports.StartsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/StartsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
const startsWith = (startsWith, options) => self => self.pipe(filter(a => a.startsWith(startsWith), {
  typeId: {
    id: StartsWithTypeId,
    annotation: {
      startsWith
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith)}`,
  jsonSchema: {
    pattern: `^${startsWith}`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.startsWith = startsWith;
const EndsWithTypeId = exports.EndsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/EndsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
const endsWith = (endsWith, options) => self => self.pipe(filter(a => a.endsWith(endsWith), {
  typeId: {
    id: EndsWithTypeId,
    annotation: {
      endsWith
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith)}`,
  jsonSchema: {
    pattern: `^.*${endsWith}$`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.endsWith = endsWith;
const IncludesTypeId = exports.IncludesTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Includes");
/**
 * @category string filters
 * @since 1.0.0
 */
const includes = (searchString, options) => self => self.pipe(filter(a => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    annotation: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.includes = includes;
const LowercasedTypeId = exports.LowercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Lowercased");
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 1.0.0
 */
const lowercased = options => self => self.pipe(filter(a => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...options
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.lowercased = lowercased;
const Lowercased = exports.Lowercased = /*#__PURE__*/string.pipe( /*#__PURE__*/lowercased({
  identifier: "Lowercased",
  title: "Lowercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const UppercasedTypeId = exports.UppercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Uppercased");
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 1.0.0
 */
const uppercased = options => self => self.pipe(filter(a => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...options
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.uppercased = uppercased;
const Uppercased = exports.Uppercased = /*#__PURE__*/string.pipe( /*#__PURE__*/uppercased({
  identifier: "Uppercased",
  title: "Uppercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const LengthTypeId = exports.LengthTypeId = filters.LengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const length = (length, options) => self => self.pipe(filter(a => a.length === length, {
  typeId: LengthTypeId,
  description: length === 1 ? `a single character` : `a string ${length} character(s) long`,
  jsonSchema: {
    minLength: length,
    maxLength: length
  },
  ...options
}));
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 1.0.0
 */
exports.length = length;
const Char = exports.Char = /*#__PURE__*/string.pipe( /*#__PURE__*/length(1), /*#__PURE__*/identifier("Char"));
/**
 * @category string filters
 * @since 1.0.0
 */
const nonEmpty = options => minLength(1, {
  description: "a non empty string",
  ...options
});
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
exports.nonEmpty = nonEmpty;
const Lowercase = exports.Lowercase = /*#__PURE__*/transform(string, Lowercased, s => s.toLowerCase(), _Function.identity).pipe( /*#__PURE__*/identifier("Lowercase"));
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
const Uppercase = exports.Uppercase = /*#__PURE__*/transform(string, Uppercased, s => s.toUpperCase(), _Function.identity).pipe( /*#__PURE__*/identifier("Uppercase"));
/**
 * @category string constructors
 * @since 1.0.0
 */
const Trimmed = exports.Trimmed = /*#__PURE__*/string.pipe( /*#__PURE__*/trimmed({
  identifier: "Trimmed",
  title: "Trimmed"
}));
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 1.0.0
 */
const Trim = exports.Trim = /*#__PURE__*/transform(string, Trimmed, s => s.trim(), _Function.identity).pipe( /*#__PURE__*/identifier("Trim"));
/**
 * Returns a achema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 1.0.0
 */
const split = separator => transform(string, array(string), S.split(separator), ReadonlyArray.join(separator));
exports.split = split;
const JsonString = /*#__PURE__*/string.pipe( /*#__PURE__*/annotations({
  [AST.IdentifierAnnotationId]: "JsonString",
  [AST.TitleAnnotationId]: "JsonString",
  [AST.DescriptionAnnotationId]: "a JSON string"
}));
/**
 * The `parseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 1.0.0
 */
const parseJson = (schema, o) => {
  if (isSchema(schema)) {
    return compose(parseJson(o), schema);
  }
  const options = schema;
  return transformOrFail(JsonString, unknown, (s, _, ast) => ParseResult.try({
    try: () => JSON.parse(s, options?.reviver),
    catch: e => ParseResult.type(ast, s, e.message)
  }), (u, _, ast) => ParseResult.try({
    try: () => JSON.stringify(u, options?.replacer, options?.space),
    catch: e => ParseResult.type(ast, u, e.message)
  }));
};
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.parseJson = parseJson;
const NonEmpty = exports.NonEmpty = /*#__PURE__*/string.pipe( /*#__PURE__*/nonEmpty({
  identifier: "NonEmpty",
  title: "NonEmpty"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const UUIDTypeId = exports.UUIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/UUID");
const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
const UUID = exports.UUID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(uuidRegex, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
const ULIDTypeId = exports.ULIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ULID");
const ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
const ULID = exports.ULID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(ulidRegex, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
const FiniteTypeId = exports.FiniteTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Finite");
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 1.0.0
 */
const finite = options => self => self.pipe(filter(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.finite = finite;
const GreaterThanTypeId = exports.GreaterThanTypeId = filters.GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
const greaterThan = (min, options) => self => self.pipe(filter(a => a > min, {
  typeId: GreaterThanTypeId,
  description: min === 0 ? "a positive number" : `a number greater than ${min}`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThan = greaterThan;
const GreaterThanOrEqualToTypeId = exports.GreaterThanOrEqualToTypeId = filters.GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
const greaterThanOrEqualTo = (min, options) => self => self.pipe(filter(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: min === 0 ? "a non-negative number" : `a number greater than or equal to ${min}`,
  jsonSchema: {
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
const MultipleOfTypeId = exports.MultipleOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/MultipleOf");
/**
 * @category number filters
 * @since 1.0.0
 */
const multipleOf = (divisor, options) => self => self.pipe(filter(a => N.remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  // spec requires positive divisor
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.multipleOf = multipleOf;
const IntTypeId = exports.IntTypeId = filters.IntTypeId;
/**
 * @category number filters
 * @since 1.0.0
 */
const int = options => self => self.pipe(filter(a => Number.isSafeInteger(a), {
  typeId: IntTypeId,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.int = int;
const LessThanTypeId = exports.LessThanTypeId = filters.LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
const lessThan = (max, options) => self => self.pipe(filter(a => a < max, {
  typeId: LessThanTypeId,
  description: max === 0 ? "a negative number" : `a number less than ${max}`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThan = lessThan;
const LessThanOrEqualToTypeId = exports.LessThanOrEqualToTypeId = filters.LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
const lessThanOrEqualTo = (max, options) => self => self.pipe(filter(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: max === 0 ? "a non-positive number" : `a number less than or equal to ${max}`,
  jsonSchema: {
    maximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualTo = lessThanOrEqualTo;
const BetweenTypeId = exports.BetweenTypeId = filters.BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 1.0.0
 */
const between = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: BetweenTypeId,
  description: `a number between ${min} and ${max}`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.between = between;
const NonNaNTypeId = exports.NonNaNTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNaN");
/**
 * @category number filters
 * @since 1.0.0
 */
const nonNaN = options => self => self.pipe(filter(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...options
}));
/**
 * @category number filters
 * @since 1.0.0
 */
exports.nonNaN = nonNaN;
const positive = options => greaterThan(0, options);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.positive = positive;
const negative = options => lessThan(0, options);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.negative = negative;
const nonPositive = options => lessThanOrEqualTo(0, options);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.nonPositive = nonPositive;
const nonNegative = options => greaterThanOrEqualTo(0, options);
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 1.0.0
 */
exports.nonNegative = nonNegative;
const clamp = (minimum, maximum) => self => transform(self, self.pipe(to, between(minimum, maximum)), self => N.clamp(self, {
  minimum,
  maximum
}), _Function.identity, {
  strict: false
});
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 1.0.0
 */
exports.clamp = clamp;
const NumberFromString = exports.NumberFromString = /*#__PURE__*/transformOrFail(string, number, (s, _, ast) => {
  if (s === "NaN") {
    return ParseResult.succeed(NaN);
  }
  if (s === "Infinity") {
    return ParseResult.succeed(Infinity);
  }
  if (s === "-Infinity") {
    return ParseResult.succeed(-Infinity);
  }
  if (s.trim() === "") {
    return ParseResult.fail(ParseResult.type(ast, s));
  }
  const n = Number(s);
  return Number.isNaN(n) ? ParseResult.fail(ParseResult.type(ast, s)) : ParseResult.succeed(n);
}, n => ParseResult.succeed(String(n))).pipe( /*#__PURE__*/identifier("NumberFromString"));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Finite = exports.Finite = /*#__PURE__*/number.pipe( /*#__PURE__*/finite({
  identifier: "Finite",
  title: "Finite"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Int = exports.Int = /*#__PURE__*/number.pipe( /*#__PURE__*/int({
  identifier: "Int",
  title: "Int"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonNaN = exports.NonNaN = /*#__PURE__*/number.pipe( /*#__PURE__*/nonNaN({
  identifier: "NonNaN",
  title: "NonNaN"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Positive = exports.Positive = /*#__PURE__*/number.pipe( /*#__PURE__*/positive({
  identifier: "Positive",
  title: "Positive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Negative = exports.Negative = /*#__PURE__*/number.pipe( /*#__PURE__*/negative({
  identifier: "Negative",
  title: "Negative"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonPositive = exports.NonPositive = /*#__PURE__*/number.pipe( /*#__PURE__*/nonPositive({
  identifier: "NonPositive",
  title: "NonPositive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonNegative = exports.NonNegative = /*#__PURE__*/number.pipe( /*#__PURE__*/nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const JsonNumberTypeId = exports.JsonNumberTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/JsonNumber");
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 1.0.0
 */
const JsonNumber = exports.JsonNumber = /*#__PURE__*/number.pipe( /*#__PURE__*/filter(n => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
}));
/**
 * @category boolean transformations
 * @since 1.0.0
 */
const Not = exports.Not = /*#__PURE__*/transform(boolean, boolean, self => !self, self => !self);
/**
 * This schema transforms a `string` into a `symbol`.
 *
 * @category symbol transformations
 * @since 1.0.0
 */
const symbol = exports.symbol = /*#__PURE__*/transform(string, symbolFromSelf, s => Symbol.for(s), sym => sym.description, {
  strict: false
}).pipe( /*#__PURE__*/identifier("symbol"));
/**
 * @category type id
 * @since 1.0.0
 */
const GreaterThanBigintTypeId = exports.GreaterThanBigintTypeId = filters.GreaterThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const greaterThanBigint = (min, options) => self => self.pipe(filter(a => a > min, {
  typeId: {
    id: GreaterThanBigintTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanBigint = greaterThanBigint;
const GreaterThanOrEqualToBigintTypeId = exports.GreaterThanOrEqualToBigintTypeId = filters.GreaterThanOrEqualToBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const greaterThanOrEqualToBigint = (min, options) => self => self.pipe(filter(a => a >= min, {
  typeId: {
    id: GreaterThanOrEqualToBigintTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min}n`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToBigint = greaterThanOrEqualToBigint;
const LessThanBigintTypeId = exports.LessThanBigintTypeId = filters.LessThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const lessThanBigint = (max, options) => self => self.pipe(filter(a => a < max, {
  typeId: {
    id: LessThanBigintTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanBigint = lessThanBigint;
const LessThanOrEqualToBigintTypeId = exports.LessThanOrEqualToBigintTypeId = filters.LessThanOrEqualToBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const lessThanOrEqualToBigint = (max, options) => self => self.pipe(filter(a => a <= max, {
  typeId: {
    id: LessThanOrEqualToBigintTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToBigint = lessThanOrEqualToBigint;
const BetweenBigintTypeId = exports.BetweenBigintTypeId = filters.BetweenBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const betweenBigint = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: {
    id: BetweenBigintTypeId,
    annotation: {
      max,
      min
    }
  },
  description: `a bigint between ${min}n and ${max}n`,
  ...options
}));
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.betweenBigint = betweenBigint;
const positiveBigint = options => greaterThanBigint(0n, options);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.positiveBigint = positiveBigint;
const negativeBigint = options => lessThanBigint(0n, options);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.negativeBigint = negativeBigint;
const nonNegativeBigint = options => greaterThanOrEqualToBigint(0n, options);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.nonNegativeBigint = nonNegativeBigint;
const nonPositiveBigint = options => lessThanOrEqualToBigint(0n, options);
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
exports.nonPositiveBigint = nonPositiveBigint;
const clampBigint = (minimum, maximum) => self => transform(self, self.pipe(to, betweenBigint(minimum, maximum)), self => BigInt_.clamp(self, {
  minimum,
  maximum
}), _Function.identity, {
  strict: false
});
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 1.0.0
 */
exports.clampBigint = clampBigint;
const bigint = exports.bigint = /*#__PURE__*/transformOrFail(string, bigintFromSelf, (s, _, ast) => {
  if (s.trim() === "") {
    return ParseResult.fail(ParseResult.type(ast, s));
  }
  return ParseResult.try({
    try: () => BigInt(s),
    catch: () => ParseResult.type(ast, s)
  });
}, n => ParseResult.succeed(String(n))).pipe( /*#__PURE__*/identifier("bigint"));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const PositiveBigintFromSelf = exports.PositiveBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/positiveBigint({
  identifier: "PositiveBigintFromSelf",
  title: "PositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const PositiveBigint = exports.PositiveBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/positiveBigint({
  identifier: "PositiveBigint",
  title: "PositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NegativeBigintFromSelf = exports.NegativeBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/negativeBigint({
  identifier: "NegativeBigintFromSelf",
  title: "NegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NegativeBigint = exports.NegativeBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/negativeBigint({
  identifier: "NegativeBigint",
  title: "NegativeBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonPositiveBigintFromSelf = exports.NonPositiveBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/nonPositiveBigint({
  identifier: "NonPositiveBigintFromSelf",
  title: "NonPositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonPositiveBigint = exports.NonPositiveBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonPositiveBigint({
  identifier: "NonPositiveBigint",
  title: "NonPositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonNegativeBigintFromSelf = exports.NonNegativeBigintFromSelf = /*#__PURE__*/bigintFromSelf.pipe( /*#__PURE__*/nonNegativeBigint({
  identifier: "NonNegativeBigintFromSelf",
  title: "NonNegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonNegativeBigint = exports.NonNegativeBigint = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonNegativeBigint({
  identifier: "NonNegativeBigint",
  title: "NonNegativeBigint"
}));
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
const BigintFromNumber = exports.BigintFromNumber = /*#__PURE__*/transformOrFail(number, bigintFromSelf, (n, _, ast) => ParseResult.try({
  try: () => BigInt(n),
  catch: () => ParseResult.type(ast, n)
}), (b, _, ast) => {
  if (b > InternalBigInt.maxSafeInteger || b < InternalBigInt.minSafeInteger) {
    return ParseResult.fail(ParseResult.type(ast, b));
  }
  return ParseResult.succeed(Number(b));
}).pipe( /*#__PURE__*/identifier("BigintFromNumber"));
/**
 * @category Secret constructors
 * @since 1.0.0
 */
const SecretFromSelf = exports.SecretFromSelf = /*#__PURE__*/declare(Secret.isSecret, {
  identifier: "SecretFromSelf",
  pretty: () => secret => String(secret),
  arbitrary: () => fc => fc.string().map(_ => Secret.fromString(_))
});
const _Secret = exports.Secret = /*#__PURE__*/transform(string, SecretFromSelf, str => Secret.fromString(str), secret => Secret.value(secret), {
  strict: false
}).pipe( /*#__PURE__*/identifier("Secret"));
/**
 * @category Duration constructors
 * @since 1.0.0
 */
const DurationFromSelf = exports.DurationFromSelf = /*#__PURE__*/declare(Duration.isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(Duration.infinity), fc.bigUint().map(_ => Duration.nanos(_)), fc.bigUint().map(_ => Duration.micros(_)), fc.maxSafeNat().map(_ => Duration.millis(_)), fc.maxSafeNat().map(_ => Duration.seconds(_)), fc.maxSafeNat().map(_ => Duration.minutes(_)), fc.maxSafeNat().map(_ => Duration.hours(_)), fc.maxSafeNat().map(_ => Duration.days(_)), fc.maxSafeNat().map(_ => Duration.weeks(_))),
  equivalence: () => Duration.Equivalence
});
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const DurationFromNanos = exports.DurationFromNanos = /*#__PURE__*/transformOrFail(bigintFromSelf, DurationFromSelf, nanos => ParseResult.succeed(Duration.nanos(nanos)), (duration, _, ast) => Option.match(Duration.toNanos(duration), {
  onNone: () => ParseResult.fail(ParseResult.type(ast, duration)),
  onSome: val => ParseResult.succeed(val)
})).pipe( /*#__PURE__*/identifier("DurationFromNanos"));
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const DurationFromMillis = exports.DurationFromMillis = /*#__PURE__*/transform(number, DurationFromSelf, ms => Duration.millis(ms), n => Duration.toMillis(n)).pipe( /*#__PURE__*/identifier("DurationFromMillis"));
const hrTime = /*#__PURE__*/tuple( /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "seconds",
  [AST.DescriptionAnnotationId]: "seconds"
})), /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "nanos",
  [AST.DescriptionAnnotationId]: "nanos"
})));
const _Duration = exports.Duration = /*#__PURE__*/transform(hrTime, DurationFromSelf, ([seconds, nanos]) => Duration.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)), duration => Duration.toHrTime(duration)).pipe( /*#__PURE__*/identifier("Duration"));
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const clampDuration = (minimum, maximum) => self => transform(self, self.pipe(to, betweenDuration(minimum, maximum)), self => Duration.clamp(self, {
  minimum,
  maximum
}), _Function.identity, {
  strict: false
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.clampDuration = clampDuration;
const LessThanDurationTypeId = exports.LessThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const lessThanDuration = (max, options) => self => self.pipe(filter(a => Duration.lessThan(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than ${Duration.decode(max)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanDuration = lessThanDuration;
const LessThanOrEqualToDurationTypeId = exports.LessThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const lessThanOrEqualToDuration = (max, options) => self => self.pipe(filter(a => Duration.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than or equal to ${Duration.decode(max)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToDuration = lessThanOrEqualToDuration;
const GreaterThanDurationTypeId = exports.GreaterThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const greaterThanDuration = (min, options) => self => self.pipe(filter(a => Duration.greaterThan(a, min), {
  typeId: {
    id: GreaterThanDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than ${Duration.decode(min)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanDuration = greaterThanDuration;
const GreaterThanOrEqualToDurationTypeId = exports.GreaterThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const greaterThanOrEqualToDuration = (min, options) => self => self.pipe(filter(a => Duration.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than or equal to ${Duration.decode(min)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToDuration = greaterThanOrEqualToDuration;
const BetweenDurationTypeId = exports.BetweenDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const betweenDuration = (minimum, maximum, options) => self => self.pipe(filter(a => Duration.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenDurationTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a Duration between ${Duration.decode(minimum)} and ${Duration.decode(maximum)}`,
  ...options
}));
/**
 * @category Uint8Array constructors
 * @since 1.0.0
 */
exports.betweenDuration = betweenDuration;
const Uint8ArrayFromSelf = exports.Uint8ArrayFromSelf = /*#__PURE__*/declare(Predicate.isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => ReadonlyArray.getEquivalence(Equivalence.strict())
});
const _Uint8Array = exports.Uint8Array = /*#__PURE__*/transform(array(number.pipe(between(0, 255, {
  title: "8-bit unsigned integer",
  description: "a 8-bit unsigned integer"
}))).pipe(description("an array of 8-bit unsigned integers")), Uint8ArrayFromSelf, a => Uint8Array.from(a), arr => Array.from(arr)).pipe( /*#__PURE__*/identifier("Uint8Array"));
const makeEncodingTransformation = (id, decode, encode) => transformOrFail(string, Uint8ArrayFromSelf, (s, _, ast) => Either.mapLeft(decode(s), decodeException => ParseResult.type(ast, s, decodeException.message)), u => ParseResult.succeed(encode(u)), {
  strict: false
}).pipe(identifier(id));
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Base64 = exports.Base64 = /*#__PURE__*/makeEncodingTransformation("Base64", Encoding.decodeBase64, Encoding.encodeBase64);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Base64Url = exports.Base64Url = /*#__PURE__*/makeEncodingTransformation("Base64Url", Encoding.decodeBase64Url, Encoding.encodeBase64Url);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Hex = exports.Hex = /*#__PURE__*/makeEncodingTransformation("Hex", Encoding.decodeHex, Encoding.encodeHex);
/**
 * @category type id
 * @since 1.0.0
 */
const MinItemsTypeId = exports.MinItemsTypeId = filters.MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const minItems = (n, options) => self => self.pipe(filter(a => a.length >= n, {
  typeId: MinItemsTypeId,
  description: `an array of at least ${n} items`,
  jsonSchema: {
    minItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minItems = minItems;
const MaxItemsTypeId = exports.MaxItemsTypeId = filters.MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const maxItems = (n, options) => self => self.pipe(filter(a => a.length <= n, {
  typeId: MaxItemsTypeId,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxItems = maxItems;
const ItemsCountTypeId = exports.ItemsCountTypeId = filters.ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const itemsCount = (n, options) => self => self.pipe(filter(a => a.length === n, {
  typeId: ItemsCountTypeId,
  description: `an array of exactly ${n} items`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  ...options
}));
/**
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.itemsCount = itemsCount;
const getNumberIndexedAccess = self => make(AST.getNumberIndexedAccess(self.ast));
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.getNumberIndexedAccess = getNumberIndexedAccess;
const head = self => transform(self, optionFromSelf(getNumberIndexedAccess(to(self))), ReadonlyArray.head, Option.match({
  onNone: () => [],
  onSome: ReadonlyArray.of
}));
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.head = head;
const headOr = exports.headOr = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess(to(self)), (as, _, ast) => as.length > 0 ? ParseResult.succeed(as[0]) : fallback ? ParseResult.succeed(fallback()) : ParseResult.fail(ParseResult.type(ast, as)), a => ParseResult.succeed(ReadonlyArray.of(a))));
/**
 * @category type id
 * @since 1.0.0
 */
const ValidDateTypeId = exports.ValidDateTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ValidDate");
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 1.0.0
 */
const validDate = options => self => self.pipe(filter(a => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...options
}));
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 1.0.0
 */
exports.validDate = validDate;
const DateFromSelf = exports.DateFromSelf = /*#__PURE__*/declare(Predicate.isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => date => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => fc => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Equivalence.Date
});
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 1.0.0
 */
const ValidDateFromSelf = exports.ValidDateFromSelf = /*#__PURE__*/DateFromSelf.pipe( /*#__PURE__*/validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}));
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 1.0.0
 */
const DateFromString = exports.DateFromString = /*#__PURE__*/transform(string, DateFromSelf, s => new Date(s), n => n.toISOString()).pipe( /*#__PURE__*/identifier("DateFromString"));
const _Date = exports.Date = /*#__PURE__*/DateFromString.pipe( /*#__PURE__*/validDate({
  identifier: "Date"
}));
const OptionNoneFrom = /*#__PURE__*/struct({
  _tag: /*#__PURE__*/literal("None")
});
const optionSomeFrom = value => struct({
  _tag: literal("Some"),
  value
});
const optionFrom = value => union(OptionNoneFrom, optionSomeFrom(value));
const optionDecode = input => input._tag === "None" ? Option.none() : Option.some(input.value);
const optionArbitrary = value => {
  const arb = arbitrary.make(optionFrom(schemaFromArbitrary(value)));
  return fc => arb(fc).map(optionDecode);
};
const optionPretty = value => Option.match({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionParse = decodeUnknown => (u, options, ast) => Option.isOption(u) ? Option.isNone(u) ? ParseResult.succeed(Option.none()) : ParseResult.map(decodeUnknown(u.value, options), Option.some) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Option transformations
 * @since 1.0.0
 */
const optionFromSelf = value => {
  return declare([value], value => optionParse(ParseResult.decodeUnknown(value)), value => optionParse(ParseResult.encodeUnknown(value)), {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: Option.getEquivalence
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.optionFromSelf = optionFromSelf;
const option = value => transform(optionFrom(value), optionFromSelf(to(value)), optionDecode, Option.match({
  onNone: () => ({
    _tag: "None"
  }),
  onSome: value => ({
    _tag: "Some",
    value
  })
}));
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.option = option;
const optionFromNullable = value => transform(nullable(value), optionFromSelf(to(value)), Option.fromNullable, Option.getOrNull);
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.optionFromNullable = optionFromNullable;
const optionFromNullish = (value, onNoneEncoding) => transform(nullish(value), optionFromSelf(to(value)), Option.fromNullable, onNoneEncoding === null ? Option.getOrNull : Option.getOrUndefined);
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.optionFromNullish = optionFromNullish;
const optionFromOrUndefined = value => transform(orUndefined(value), optionFromSelf(to(value)), Option.fromNullable, Option.getOrUndefined);
exports.optionFromOrUndefined = optionFromOrUndefined;
const rightFrom = right => struct({
  _tag: literal("Right"),
  right
}).pipe(description(`RightFrom<${format(right)}>`));
const leftFrom = left => struct({
  _tag: literal("Left"),
  left
}).pipe(description(`LeftFrom<${format(left)}>`));
const eitherFrom = (left, right) => union(rightFrom(right), leftFrom(left)).pipe(description(`EitherFrom<${format(left)}, ${format(right)}>`));
const eitherDecode = input => input._tag === "Left" ? Either.left(input.left) : Either.right(input.right);
const eitherArbitrary = (left, right) => {
  const arb = arbitrary.make(eitherFrom(schemaFromArbitrary(left), schemaFromArbitrary(right)));
  return fc => arb(fc).map(eitherDecode);
};
const eitherPretty = (left, right) => Either.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherParse = (decodeUnknownLeft, parseright) => (u, options, ast) => Either.isEither(u) ? Either.match(u, {
  onLeft: left => ParseResult.map(decodeUnknownLeft(left, options), Either.left),
  onRight: right => ParseResult.map(parseright(right, options), Either.right)
}) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Either transformations
 * @since 1.0.0
 */
const eitherFromSelf = ({
  left,
  right
}) => {
  return declare([left, right], (left, right) => eitherParse(ParseResult.decodeUnknown(left), ParseResult.decodeUnknown(right)), (left, right) => eitherParse(ParseResult.encodeUnknown(left), ParseResult.encodeUnknown(right)), {
    description: `Either<${format(left)}, ${format(right)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: Either.getEquivalence
  });
};
exports.eitherFromSelf = eitherFromSelf;
const makeLeftFrom = left => ({
  _tag: "Left",
  left
});
const makeRightFrom = right => ({
  _tag: "Right",
  right
});
/**
 * @category Either transformations
 * @since 1.0.0
 */
const either = ({
  left,
  right
}) => transform(eitherFrom(left, right), eitherFromSelf({
  left: to(left),
  right: to(right)
}), eitherDecode, Either.match({
  onLeft: makeLeftFrom,
  onRight: makeRightFrom
}));
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.eitherFromUnion({ left: Schema.string, right: Schema.number })
 *
 * @category Either transformations
 * @since 1.0.0
 */
exports.either = either;
const eitherFromUnion = ({
  left,
  right
}) => {
  const toleft = to(left);
  const toright = to(right);
  const fromLeft = transform(left, leftFrom(toleft), makeLeftFrom, l => l.left);
  const fromRight = transform(right, rightFrom(toright), makeRightFrom, r => r.right);
  return transform(union(fromRight, fromLeft), eitherFromSelf({
    left: toleft,
    right: toright
  }), from => from._tag === "Left" ? Either.left(from.left) : Either.right(from.right), Either.match({
    onLeft: makeLeftFrom,
    onRight: makeRightFrom
  }));
};
exports.eitherFromUnion = eitherFromUnion;
const isMap = u => u instanceof Map;
const readonlyMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const readonlyMapEquivalence = (key, value) => {
  const arrayEquivalence = ReadonlyArray.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
const readonlyMapParse = decodeUnknown => (u, options, ast) => isMap(u) ? ParseResult.map(decodeUnknown(Array.from(u.entries()), options), as => new Map(as)) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
const readonlyMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], (key, value) => readonlyMapParse(ParseResult.decodeUnknown(array(tuple(key, value)))), (key, value) => readonlyMapParse(ParseResult.encodeUnknown(array(tuple(key, value)))), {
    description: `ReadonlyMap<${format(key)}, ${format(value)}>`,
    pretty: readonlyMapPretty,
    arbitrary: readonlyMapArbitrary,
    equivalence: readonlyMapEquivalence
  });
};
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
exports.readonlyMapFromSelf = readonlyMapFromSelf;
const readonlyMap = ({
  key,
  value
}) => transform(array(tuple(key, value)), readonlyMapFromSelf({
  key: to(key),
  value: to(value)
}), as => new Map(as), map => Array.from(map.entries()));
exports.readonlyMap = readonlyMap;
const isSet = u => u instanceof Set;
const readonlySetArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
const readonlySetEquivalence = item => {
  const arrayEquivalence = ReadonlyArray.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
const readonlySetParse = decodeUnknown => (u, options, ast) => isSet(u) ? ParseResult.map(decodeUnknown(Array.from(u.values()), options), as => new Set(as)) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
const readonlySetFromSelf = item => {
  return declare([item], item => readonlySetParse(ParseResult.decodeUnknown(array(item))), item => readonlySetParse(ParseResult.encodeUnknown(array(item))), {
    description: `ReadonlySet<${format(item)}>`,
    pretty: readonlySetPretty,
    arbitrary: readonlySetArbitrary,
    equivalence: readonlySetEquivalence
  });
};
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
exports.readonlySetFromSelf = readonlySetFromSelf;
const readonlySet = item => transform(array(item), readonlySetFromSelf(to(item)), as => new Set(as), set => Array.from(set));
exports.readonlySet = readonlySet;
const bigDecimalPretty = () => val => `BigDecimal(${BigDecimal.format(BigDecimal.normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => BigDecimal.make(value, scale));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
const BigDecimalFromSelf = exports.BigDecimalFromSelf = /*#__PURE__*/declare(BigDecimal.isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => BigDecimal.Equivalence
});
const _BigDecimal = exports.BigDecimal = /*#__PURE__*/transformOrFail(string, BigDecimalFromSelf, (num, _, ast) => BigDecimal.fromString(num).pipe(Option.match({
  onNone: () => ParseResult.fail(ParseResult.type(ast, num)),
  onSome: val => ParseResult.succeed(BigDecimal.normalize(val))
})), val => ParseResult.succeed(BigDecimal.format(BigDecimal.normalize(val)))).pipe( /*#__PURE__*/identifier("BigDecimal"));
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
const BigDecimalFromNumber = exports.BigDecimalFromNumber = /*#__PURE__*/transformOrFail(number, BigDecimalFromSelf, num => ParseResult.succeed(BigDecimal.fromNumber(num)), val => ParseResult.succeed(BigDecimal.unsafeToNumber(val))).pipe( /*#__PURE__*/identifier("BigDecimalFromNumber"));
/**
 * @category type id
 * @since 1.0.0
 */
const GreaterThanBigDecimalTypeId = exports.GreaterThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const greaterThanBigDecimal = (min, options) => self => self.pipe(filter(a => BigDecimal.greaterThan(a, min), {
  typeId: {
    id: GreaterThanBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than ${BigDecimal.format(min)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanBigDecimal = greaterThanBigDecimal;
const GreaterThanOrEqualToBigDecimalTypeId = exports.GreaterThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const greaterThanOrEqualToBigDecimal = (min, options) => self => self.pipe(filter(a => BigDecimal.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than or equal to ${BigDecimal.format(min)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToBigDecimal = greaterThanOrEqualToBigDecimal;
const LessThanBigDecimalTypeId = exports.LessThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const lessThanBigDecimal = (max, options) => self => self.pipe(filter(a => BigDecimal.lessThan(a, max), {
  typeId: {
    id: LessThanBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than ${BigDecimal.format(max)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanBigDecimal = lessThanBigDecimal;
const LessThanOrEqualToBigDecimalTypeId = exports.LessThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const lessThanOrEqualToBigDecimal = (max, options) => self => self.pipe(filter(a => BigDecimal.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanOrEqualToBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than or equal to ${BigDecimal.format(max)}`,
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToBigDecimal = lessThanOrEqualToBigDecimal;
const PositiveBigDecimalTypeId = exports.PositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/PositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const positiveBigDecimal = options => self => self.pipe(filter(a => BigDecimal.isPositive(a), {
  typeId: {
    id: PositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a positive BigDecimal`,
  ...options
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.positiveBigDecimal = positiveBigDecimal;
const PositiveBigDecimalFromSelf = exports.PositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf",
  title: "PositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NonNegativeBigDecimalTypeId = exports.NonNegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const nonNegativeBigDecimal = options => self => self.pipe(filter(a => a.value >= 0n, {
  typeId: {
    id: NonNegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-negative BigDecimal`,
  ...options
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.nonNegativeBigDecimal = nonNegativeBigDecimal;
const NonNegativeBigDecimalFromSelf = exports.NonNegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf",
  title: "NonNegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NegativeBigDecimalTypeId = exports.NegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const negativeBigDecimal = options => self => self.pipe(filter(a => BigDecimal.isNegative(a), {
  typeId: {
    id: NegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a negative BigDecimal`,
  ...options
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.negativeBigDecimal = negativeBigDecimal;
const NegativeBigDecimalFromSelf = exports.NegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf",
  title: "NegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NonPositiveBigDecimalTypeId = exports.NonPositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonPositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const nonPositiveBigDecimal = options => self => self.pipe(filter(a => a.value <= 0n, {
  typeId: {
    id: NonPositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-positive BigDecimal`,
  ...options
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.nonPositiveBigDecimal = nonPositiveBigDecimal;
const NonPositiveBigDecimalFromSelf = exports.NonPositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf",
  title: "NonPositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const BetweenBigDecimalTypeId = exports.BetweenBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const betweenBigDecimal = (minimum, maximum, options) => self => self.pipe(filter(a => BigDecimal.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenBigDecimalTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a BigDecimal between ${BigDecimal.format(minimum)} and ${BigDecimal.format(maximum)}`,
  ...options
}));
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
exports.betweenBigDecimal = betweenBigDecimal;
const clampBigDecimal = (minimum, maximum) => self => transform(self, self.pipe(to, betweenBigDecimal(minimum, maximum)), self => BigDecimal.clamp(self, {
  minimum,
  maximum
}), _Function.identity, {
  strict: false
});
/**
 * Negates a `BigDecimal`.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
exports.clampBigDecimal = clampBigDecimal;
const negateBigDecimal = self => transform(self, to(self), self => BigDecimal.negate(self), self => BigDecimal.negate(self), {
  strict: false
});
exports.negateBigDecimal = negateBigDecimal;
const chunkArbitrary = item => fc => fc.array(item(fc)).map(Chunk.fromIterable);
const chunkPretty = item => c => `Chunk(${Chunk.toReadonlyArray(c).map(item).join(", ")})`;
const chunkParse = decodeUnknown => (u, options, ast) => Chunk.isChunk(u) ? Chunk.isEmpty(u) ? ParseResult.succeed(Chunk.empty()) : ParseResult.map(decodeUnknown(Chunk.toReadonlyArray(u), options), Chunk.fromIterable) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
const chunkFromSelf = item => {
  return declare([item], item => chunkParse(ParseResult.decodeUnknown(array(item))), item => chunkParse(ParseResult.encodeUnknown(array(item))), {
    description: `Chunk<${format(item)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: Chunk.getEquivalence
  });
};
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
exports.chunkFromSelf = chunkFromSelf;
const chunk = item => transform(array(item), chunkFromSelf(to(item)), as => as.length === 0 ? Chunk.empty() : Chunk.fromIterable(as), Chunk.toReadonlyArray);
exports.chunk = chunk;
const toData = a => Array.isArray(a) ? Data.array(a) : Data.struct(a);
const dataArbitrary = item => fc => item(fc).map(toData);
const dataPretty = item => d => `Data(${item(d)})`;
const dataParse = decodeUnknown => (u, options, ast) => Equal.isEqual(u) ? ParseResult.map(decodeUnknown(u, options), toData) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Data transformations
 * @since 1.0.0
 */
const dataFromSelf = item => {
  return declare([item], item => dataParse(ParseResult.decodeUnknown(item)), item => dataParse(ParseResult.encodeUnknown(item)), {
    description: `Data<${format(item)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary,
    equivalence: () => Equal.equals
  });
};
/**
 * @category Data transformations
 * @since 1.0.0
 */
exports.dataFromSelf = dataFromSelf;
const data = item => transform(item, dataFromSelf(to(item)), toData, a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a), {
  strict: false
});
/**
 * @category classes
 * @since 1.0.0
 */
exports.data = data;
const Class = () => fields => makeClass(struct(fields), fields, Data.Class);
/**
 * @category classes
 * @since 1.0.0
 */
exports.Class = Class;
const TaggedClass = () => (tag, fields) => {
  const fieldsWithTag = {
    ...fields,
    _tag: literal(tag)
  };
  return makeClass(struct(fieldsWithTag), fieldsWithTag, Data.Class, {
    _tag: tag
  });
};
/**
 * @category classes
 * @since 1.0.0
 */
exports.TaggedClass = TaggedClass;
const TaggedError = () => (tag, fields) => {
  const fieldsWithTag = {
    ...fields,
    _tag: literal(tag)
  };
  return makeClass(struct(fieldsWithTag), fieldsWithTag, Data.Error, {
    _tag: tag
  });
};
/**
 * @category classes
 * @since 1.0.0
 */
exports.TaggedError = TaggedError;
const TaggedRequest = () => (tag, Failure, Success, fields) => {
  class SerializableRequest extends Request.Class {
    get [InternalSerializable.symbol]() {
      return this.constructor;
    }
    get [InternalSerializable.symbolResult]() {
      return {
        Failure,
        Success
      };
    }
  }
  const fieldsWithTag = {
    ...fields,
    _tag: literal(tag)
  };
  return makeClass(struct(fieldsWithTag), fieldsWithTag, SerializableRequest, {
    _tag: tag
  });
};
exports.TaggedRequest = TaggedRequest;
const makeClass = (selfSchema, selfFields, Base, additionalProps) => {
  const validator = Parser.validateSync(selfSchema);
  return class extends Base {
    constructor(props, disableValidation = false) {
      if (additionalProps !== undefined) {
        props = {
          ...additionalProps,
          ...props
        };
      }
      if (disableValidation !== true) {
        props = validator(props);
      }
      super(props, true);
    }
    static [TypeId] = InternalSchema.variance;
    toString() {
      return Pretty.make(this.constructor)(this);
    }
    static pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
    static get ast() {
      const toSchema = to(selfSchema);
      const pretty = Pretty.make(toSchema);
      const arb = arbitrary.make(toSchema);
      const declaration = declare(input => input instanceof this, {
        identifier: this.name,
        title: this.name,
        description: `an instance of ${this.name}`,
        pretty: () => self => `${self.constructor.name}(${pretty(self)})`,
        arbitrary: () => fc => arb(fc).map(props => new this(props))
      });
      const transformation = transform(selfSchema, declaration, input => new this(input, true), _Function.identity);
      return transformation.ast;
    }
    static struct = selfSchema;
    static extend() {
      return fields => {
        const newFields = {
          ...selfFields,
          ...fields
        };
        return makeClass(struct(newFields), newFields, this, additionalProps);
      };
    }
    static transformOrFail() {
      return (fields, decode, encode) => {
        const newFields = {
          ...selfFields,
          ...fields
        };
        return makeClass(transformOrFail(selfSchema, to(struct(newFields)), decode, encode), newFields, this, additionalProps);
      };
    }
    static transformOrFailFrom() {
      return (fields, decode, encode) => {
        const newFields = {
          ...selfFields,
          ...fields
        };
        return makeClass(transformOrFail(from(selfSchema), struct(newFields), decode, encode), newFields, this, additionalProps);
      };
    }
  };
};
const FiberIdCompositeFrom = /*#__PURE__*/struct({
  _tag: literal("Composite"),
  left: suspend(() => FiberIdFrom),
  right: suspend(() => FiberIdFrom)
}).pipe( /*#__PURE__*/identifier("FiberIdCompositeFrom"));
const FiberIdNoneFrom = /*#__PURE__*/struct({
  _tag: literal("None")
}).pipe( /*#__PURE__*/identifier("FiberIdNoneFrom"));
const FiberIdRuntimeFrom = /*#__PURE__*/struct({
  _tag: literal("Runtime"),
  id: Int.pipe(nonNegative({
    title: "id",
    description: "id"
  })),
  startTimeMillis: Int.pipe(nonNegative({
    title: "startTimeMillis",
    description: "startTimeMillis"
  }))
}).pipe( /*#__PURE__*/identifier("FiberIdRuntimeFrom"));
const FiberIdFrom = /*#__PURE__*/union(FiberIdCompositeFrom, FiberIdNoneFrom, FiberIdRuntimeFrom).pipe( /*#__PURE__*/identifier("FiberIdFrom"));
const fiberIdFromArbitrary = /*#__PURE__*/arbitrary.make(FiberIdFrom);
const fiberIdArbitrary = fc => fiberIdFromArbitrary(fc).map(fiberIdDecode);
const fiberIdPretty = fiberId => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
  }
};
/**
 * @category FiberId constructors
 * @since 1.0.0
 */
const FiberIdFromSelf = exports.FiberIdFromSelf = /*#__PURE__*/declare(FiberId.isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary,
  equivalence: () => Equal.equals
});
const fiberIdDecode = input => {
  switch (input._tag) {
    case "Composite":
      return FiberId.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
    case "None":
      return FiberId.none;
    case "Runtime":
      return FiberId.runtime(input.id, input.startTimeMillis);
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
const _FiberId = exports.FiberId = /*#__PURE__*/transform(FiberIdFrom, FiberIdFromSelf, fiberIdDecode, fiberIdEncode).pipe( /*#__PURE__*/identifier("FiberId"));
const causeDieFrom = defect => struct({
  _tag: literal("Die"),
  defect
});
const CauseEmptyFrom = /*#__PURE__*/struct({
  _tag: /*#__PURE__*/literal("Empty")
});
const causeFailFrom = error => struct({
  _tag: literal("Fail"),
  error
});
const CauseInterruptFrom = /*#__PURE__*/struct({
  _tag: /*#__PURE__*/literal("Interrupt"),
  fiberId: FiberIdFrom
});
const causeParallelFrom = causeFrom => struct({
  _tag: literal("Parallel"),
  left: causeFrom,
  right: causeFrom
});
const causeSequentialFrom = causeFrom => struct({
  _tag: literal("Sequential"),
  left: causeFrom,
  right: causeFrom
});
const causeFrom = (error, defect) => {
  const recur = suspend(() => out);
  const out = union(causeDieFrom(defect), CauseEmptyFrom, causeFailFrom(error), CauseInterruptFrom, causeParallelFrom(recur), causeSequentialFrom(recur)).pipe(description(`CauseFrom<${format(error)}>`));
  return out;
};
const causeArbitrary = (error, defect) => {
  const arb = arbitrary.make(causeFrom(schemaFromArbitrary(error), schemaFromArbitrary(defect)));
  return fc => arb(fc).map(causeDecode);
};
const causePretty = error => cause => {
  const f = cause => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty";
      case "Die":
        return `Cause.die(${Cause.pretty(cause)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
      case "Fail":
        return `Cause.fail(${error(cause.error)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
    }
  };
  return f(cause);
};
const causeParse = decodeUnknown => (u, options, ast) => Cause.isCause(u) ? ParseResult.map(decodeUnknown(causeEncode(u), options), causeDecode) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Cause transformations
 * @since 1.0.0
 */
const causeFromSelf = ({
  defect = unknown,
  error
}) => {
  return declare([error, defect], (error, defect) => causeParse(ParseResult.decodeUnknown(causeFrom(error, defect))), (error, defect) => causeParse(ParseResult.encodeUnknown(causeFrom(error, defect))), {
    description: `Cause<${format(error)}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary,
    equivalence: () => Equal.equals
  });
};
exports.causeFromSelf = causeFromSelf;
function causeDecode(cause) {
  switch (cause._tag) {
    case "Die":
      return Cause.die(cause.defect);
    case "Empty":
      return Cause.empty;
    case "Interrupt":
      return Cause.interrupt(fiberIdDecode(cause.fiberId));
    case "Fail":
      return Cause.fail(cause.error);
    case "Parallel":
      return Cause.parallel(causeDecode(cause.left), causeDecode(cause.right));
    case "Sequential":
      return Cause.sequential(causeDecode(cause.left), causeDecode(cause.right));
  }
}
function causeEncode(cause) {
  switch (cause._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause.fiberId
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause.error
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
  }
}
const causeDefectPretty = /*#__PURE__*/transform(unknown, unknown, _Function.identity, defect => {
  if (Predicate.isObject(defect)) {
    return Cause.pretty(Cause.die(defect));
  }
  return String(defect);
});
/**
 * @category Cause transformations
 * @since 1.0.0
 */
const cause = ({
  defect = causeDefectPretty,
  error
}) => transform(causeFrom(error, defect), causeFromSelf({
  error: to(error),
  defect: to(defect)
}), causeDecode, causeEncode);
exports.cause = cause;
const exitFailureFrom = (error, defect) => struct({
  _tag: literal("Failure"),
  cause: causeFrom(error, defect)
});
const exitSuccessFrom = value => struct({
  _tag: literal("Success"),
  value
});
const exitFrom = (error, value, defect) => union(exitFailureFrom(error, defect), exitSuccessFrom(value));
const exitDecode = input => {
  switch (input._tag) {
    case "Failure":
      return Exit.failCause(causeDecode(input.cause));
    case "Success":
      return Exit.succeed(input.value);
  }
};
const exitArbitrary = (error, value, defect) => {
  const arb = arbitrary.make(exitFrom(schemaFromArbitrary(error), schemaFromArbitrary(value), schemaFromArbitrary(defect)));
  return fc => arb(fc).map(exitDecode);
};
const exitPretty = (error, value) => exit => exit._tag === "Failure" ? `Exit.failCause(${causePretty(error)(exit.cause)})` : `Exit.succeed(${value(exit.value)})`;
const exitParse = (decodeUnknownCause, decodeUnknownValue) => (u, options, ast) => Exit.isExit(u) ? Exit.match(u, {
  onFailure: cause => ParseResult.map(decodeUnknownCause(cause, options), Exit.failCause),
  onSuccess: value => ParseResult.map(decodeUnknownValue(value, options), Exit.succeed)
}) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category Exit transformations
 * @since 1.0.0
 */
const exitFromSelf = ({
  defect = unknown,
  failure,
  success
}) => declare([failure, success, defect], (failure, success, defect) => exitParse(ParseResult.decodeUnknown(causeFromSelf({
  error: failure,
  defect
})), ParseResult.decodeUnknown(success)), (failure, success, defect) => exitParse(ParseResult.encodeUnknown(causeFromSelf({
  error: failure,
  defect
})), ParseResult.encodeUnknown(success)), {
  description: `Exit<${format(failure)}, ${format(success)}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary,
  equivalence: () => Equal.equals
});
/**
 * @category Exit transformations
 * @since 1.0.0
 */
exports.exitFromSelf = exitFromSelf;
const exit = ({
  defect = causeDefectPretty,
  failure,
  success
}) => transform(exitFrom(failure, success, defect), exitFromSelf({
  failure: to(failure),
  success: to(success),
  defect: to(defect)
}), exitDecode, exit => exit._tag === "Failure" ? {
  _tag: "Failure",
  cause: exit.cause
} : {
  _tag: "Success",
  value: exit.value
});
exports.exit = exit;
const hashSetArbitrary = item => fc => fc.array(item(fc)).map(as => HashSet.fromIterable(as));
const hashSetPretty = item => set => `HashSet(${Array.from(set).map(a => item(a)).join(", ")})`;
const hashSetEquivalence = item => {
  const arrayEquivalence = ReadonlyArray.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashSetParse = decodeUnknown => (u, options, ast) => HashSet.isHashSet(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => HashSet.fromIterable(as)) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
const hashSetFromSelf = item => {
  return declare([item], item => hashSetParse(ParseResult.decodeUnknown(array(item))), item => hashSetParse(ParseResult.encodeUnknown(array(item))), {
    description: `HashSet<${format(item)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
exports.hashSetFromSelf = hashSetFromSelf;
const hashSet = item => transform(array(item), hashSetFromSelf(to(item)), as => HashSet.fromIterable(as), set => Array.from(set));
exports.hashSet = hashSet;
const hashMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => HashMap.fromIterable(as));
const hashMapPretty = (key, value) => map => `HashMap([${Array.from(map).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const hashMapEquivalence = (key, value) => {
  const arrayEquivalence = ReadonlyArray.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashMapParse = decodeUnknown => (u, options, ast) => HashMap.isHashMap(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => HashMap.fromIterable(as)) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
const hashMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], (key, value) => hashMapParse(ParseResult.decodeUnknown(array(tuple(key, value)))), (key, value) => hashMapParse(ParseResult.encodeUnknown(array(tuple(key, value)))), {
    description: `HashMap<${format(key)}, ${format(value)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
exports.hashMapFromSelf = hashMapFromSelf;
const hashMap = ({
  key,
  value
}) => transform(array(tuple(key, value)), hashMapFromSelf({
  key: to(key),
  value: to(value)
}), as => HashMap.fromIterable(as), map => Array.from(map));
exports.hashMap = hashMap;
const listArbitrary = item => fc => fc.array(item(fc)).map(as => List.fromIterable(as));
const listPretty = item => set => `List(${Array.from(set).map(a => item(a)).join(", ")})`;
const listEquivalence = item => {
  const arrayEquivalence = ReadonlyArray.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const listParse = decodeUnknown => (u, options, ast) => List.isList(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => List.fromIterable(as)) : ParseResult.fail(ParseResult.type(ast, u));
/**
 * @category List transformations
 * @since 1.0.0
 */
const listFromSelf = item => {
  return declare([item], item => listParse(ParseResult.decodeUnknown(array(item))), item => listParse(ParseResult.encodeUnknown(array(item))), {
    description: `List<${format(item)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
/**
 * @category List transformations
 * @since 1.0.0
 */
exports.listFromSelf = listFromSelf;
const list = item => transform(array(item), listFromSelf(to(item)), as => List.fromIterable(as), set => Array.from(set));
exports.list = list;
const schemaFromArbitrary = value => suspend(() => any).pipe(annotations({
  [hooks.ArbitraryHookId]: () => value
}));
//# sourceMappingURL=Schema.js.map