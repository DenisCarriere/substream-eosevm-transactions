import { AnyMessage, IMessageTypeRegistry, JsonObject, Message } from "@bufbuild/protobuf";
import { type CallOptions, type ConnectError, type Transport } from "@connectrpc/connect";
import { BlockScopedData, BlockUndoSignal, Clock, Error as FatalError, InitialSnapshotComplete, InitialSnapshotData, ModulesProgress, Request, Response, SessionInit } from "@substreams/core/proto";
import { EventEmitter } from "eventemitter3";
export type CancelFn = () => void;
export declare class TypedEventEmitter<Events extends Record<string, any>> {
    private emitter;
    emit<EventName extends keyof Events & string>(eventName: EventName, ...eventArg: Events[EventName]): boolean;
    on<EventName extends keyof Events & string>(eventName: EventName, handler: (...eventArg: Events[EventName]) => void): EventEmitter<string | symbol, any>;
    once<EventName extends keyof Events & string>(eventName: EventName, handler: (...eventArg: Events[EventName]) => void): EventEmitter<string | symbol, any>;
    removeListener<EventName extends keyof Events & string>(eventName: EventName, handler: (...eventArg: Events[EventName]) => void): EventEmitter<string | symbol, any>;
    removeAllListeners<EventName extends keyof Events & string>(eventName?: EventName): EventEmitter<string | symbol, any>;
    eventNames(): (string | symbol)[];
    listenerCount<EventName extends keyof Events & string>(eventName: EventName): number;
    off<EventName extends keyof Events & string>(eventName: EventName, handler: (...eventArg: Events[EventName]) => void): EventEmitter<string | symbol, any>;
}
/**
 * A map of event names to argument tuples
 */
export type LocalEventTypes = {
    block: [block: BlockScopedData];
    session: [session: SessionInit];
    progress: [progress: ModulesProgress];
    undo: [undo: BlockUndoSignal];
    debugSnapshotData: [undo: InitialSnapshotData];
    debugSnapshotComplete: [undo: InitialSnapshotComplete];
    response: [response: Response];
    cursor: [cursor: string, clock: Clock];
    clock: [clock: Clock];
    output: [message: Message<AnyMessage>, cursor: string, clock: Clock];
    anyMessage: [message: JsonObject, cursor: string, clock: Clock];
    close: [error?: ConnectError];
    fatalError: [error: FatalError];
};
export declare class BlockEmitter extends TypedEventEmitter<LocalEventTypes> {
    transport: Transport;
    request: Request;
    registry: IMessageTypeRegistry;
    options?: CallOptions;
    cancelFn?: CancelFn;
    constructor(transport: Transport, request: Request, registry: IMessageTypeRegistry, options?: CallOptions);
    /**
     * Stop streaming blocks
     */
    stop(): void;
    /**
     * Start streaming blocks
     */
    start(): CancelFn;
}
//# sourceMappingURL=BlockEmitter.d.ts.map